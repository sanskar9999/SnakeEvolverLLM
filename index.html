<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake AI King of the Hill</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        #mainLayout {
            display: flex;
            flex-direction: row;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
            justify-content: center;
        }
        #tournamentSection {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
            border: 1px solid #34495e;
            padding: 20px;
            background-color: #34495e;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 8px;
            flex-grow: 1;
            max-width: 700px;
        }
        #leaderboardSection {
            display: flex;
            flex-direction: column;
            margin-top: 10px;
            border: 1px solid #34495e;
            padding: 20px;
            background-color: #34495e;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 8px;
            width: 300px;
            min-width: 250px;
        }
        #leaderboardSection h2 {
            margin-top: 0;
            text-align: center;
            color: #f1c40f;
        }
        #leaderboard {
            max-height: 450px;
            overflow-y: auto;
            padding-right: 10px;
        }
        .leaderboard-item {
            padding: 8px 5px;
            border-bottom: 1px solid #2c3e50;
            display: flex;
            justify-content: space-between;
        }
         #e74c3c; }

        #loadingStatus, #autoBattleStatus {
            font-style: italic;
            color: #bdc3c7;
            margin-top: 5px;
        }
        .error-message {
            color: #e74c3c;
            font-weight: bold;
            margin-top: 10px;
        }

        @media (max-width: 900px) {
            #mainLayout { flex-direction: column; align-items: center; }
            #leaderboardSection { width: 90%; max-width: 700px; margin-top: 20px; }
            #tournamentSection { width: 90%; }
        }
         @media (max-width: 600px) { /* Adjusted breakpoint for config controls */
            #controls, #configControls { flex-direction: column; }
             button, #controls label, #configControls div { width: 100%; text-align: center; margin-bottom: 5px;}
             #configControls input[type="number"] { width: 80%; margin: 0 auto; }
             #controls label input { margin-right: 5px;}
        }
    </style>
</head>
<body>
    <h1>Snake AI: King of the Hill</h1>

    <div id="mainLayout">
        <div id="tournamentSection">
            <div id="configControls">
                <div>
                    <label for="gridWidthInput">Grid W:</label>
                    <input type="number" id="gridWidthInput" value="20" min="10" max="100">
                    <label for="gridHeightInput">H:</label>
                    <input type="number" id="gridHeightInput" value="10" min="10" max="50">
                </div>
                <div>
                    <label for="cellSizeInput">Cell (px):</label>
                    <input type="number" id="cellSizeInput" value="28" min="5" max="50">
                    <label for="initialSnakeLengthInput">Len:</label>
                    <input type="number" id="initialSnakeLengthInput" value="3" min="1" max="10">
                </div>
                <button id="applyConfigBtn">Apply Config & Restart</button>
            </div>
            <div id="controls">
                <button id="startTournamentBtn">Start New Tournament</button>
                <button id="nextBattleBtn" disabled>Next Battle</button>
                <button id="fullscreenBtn">Toggle Fullscreen</button>
                <label for="autoBattleCheckbox" style="margin-left: 10px; display: inline-flex; align-items: center; cursor:pointer;">
                    <input type="checkbox" id="autoBattleCheckbox" style="margin-right: 5px;">Auto-Advance
                </label>
                <span id="autoBattleStatus" style="font-size: 0.9em;"></span>
            </div>
            <div id="tournamentInfo">
                <div id="kingInfo">Current King: --- (Reign Wins: 0)</div>
                <div id="aiNames">Player 1: --- vs Player 2: ---</div>
            </div>
            <div id="scores">Score: P1 (0) - P2 (0)</div>
            <canvas id="gameCanvas"></canvas>
            <div id="status">Welcome! Click "Start New Tournament".</div>
            <div id="loadingStatus"></div>
            <div id="errorMessage" class="error-message"></div>
        </div>

        <div id="leaderboardSection">
            <h2>Tournament Leaderboard</h2>
            <div id="leaderboard">
                <p>No tournament data yet.</p>
            </div>
        </div>
    </div>

    <script type="module">
        // ---.leaderboard-item:last-child { border-bottom: none; }
        .leaderboard-name { font-weight: bold; }
        .leaderboard-wins { color: #f1c40f; }

        canvas {
            border: 2px solid #ecf0f1;
            background-color: #1e272e;
            margin-bottom: 15px;
            border-radius: 4px;
            display: block; /* Helps with centering if parent is flex */
        }
        #controls {
            margin-bottom: 15px;
            display: flex;
            flex-direction: column; /* Stack controls vertically */
            gap: 10px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }
        .control-group label { white-space: nowrap; }
        .control-group input[type="number"] {
            width: 60px;
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #7f8c8d;
            background-color: #ecf0f1;
            color: #2c3e50;
        }

         #tournamentInfo {
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        button {
            padding: 10px 18px;
            font-size: 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover { background-color: #2980b9; }
        button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
        }
        #status, #scores, #aiNames, #kingInfo {
            margin-top: 5px;
            font-size: 1.1em;
            text-align: center;
        }
        #kingInfo { font-weight: bold; color: #f1c40f; }
        #aiNames span {
            padding: 4px 8px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
        }
        .snake1-name-display { background-color: #2ecc71; }
        .snake2- Game Configuration (will be updated by UI) ---
        let GRID_WIDTH = 20;
        let GRID_HEIGHT = 10;
        let INITIAL_SNAKE_LENGTH = 3;
        let CELL_SIZE = 28;
        let MAX_STEPS_PER_GAME = GRID_WIDTH * GRID_HEIGHT * 2; // Initial calculation
        
        const AUTO_BATTLE_DELAY_MS = 3000;

        const SNAKE_1_COLOR = "#2ecc71";
        const SNAKE_1_HEAD_COLOR = "#27ae60";
        const SNAKE_2_COLOR = "#e74c3c";
        const SNAKE_2_HEAD_COLOR = "#c0392b";
        const FOOD_COLOR = "#f1c40f";
        // const GRID_LINE_COLOR = "#7f8c8d"; // Grid lines currently disabled in render

        // --- Python Game Engine Code (Unchanged from previous version) ---
        const PYTHON_ENGINE_CODE = `
import random
from collections import deque
from dataclasses import dataclass
from typing import List, Tuple, Optional, Callable # For type hints if AIs use them
import traceback # For better error reporting from AI

# --- Game Classes (adapted from your main_snake_game.py) ---
@dataclass
class Food:
    position: Tuple[int, int]

class Snake:
    DIRECTIONS_MAP = [(0, -1), (1, 0), (0, 1), (-1, 0)] # UP, RIGHT, DOWN, LEFT
    ACTIONS_LIST = [0, 1, 2, 3]
    OPPOSITE_ACTIONS_MAP = {0: 2, 1: 3, 2: 0, 3: 1}

    def __init__(self, x: int, y: int, grid_width: int, grid_height: int, initial_length: int, initial_direction_idx: Optional[int] = None):
        self.grid_width = grid_width
        self.grid_height = grid_height
        self.initial_length = initial_length 

        self.positions = deque()
        self.direction_idx = initial_direction_idx if initial_direction_idx is not None \
                             else random.choice(self.ACTIONS_LIST)
        self.length = initial_length
        self.score = 0
        self.is_alive = True
        self.name = "Snake" 

        head_pos = (x,y)
        self.positions.appendleft(head_pos)
        
        current_segment_name-display { background-color: #e74c3c; }

        #loadingStatus, #autoBattleStatus {
            font-style: italic;
            color: #bdc3c7;
            margin-top: 5px;
            min-height: 1.2em; /* Reserve space */
        }
        .error-message {
            color: #e74c3c;
            font-weight: bold;
            margin-top: 10px;
        }

        @media (max-width: 900px) {
            #mainLayout { flex-direction: column; align-items: center; }
            #leaderboardSection { width: 90%; max-width: 700px; margin-top: 20px; }
            #tournamentSection { width: 90%; }
        }
         @media (max-width: 480px) {
            .control-group { flex-direction: column; }
            .control-group button, .control-group label, .control-group input[type="number"] {
                 width: 90%; /* Make them take more width */
                 margin-left: auto; margin-right: auto; /* Center */
             }
             .control-group label input[type="checkbox"] { margin-right: 5px;}
        }
    </style>
</head>
<body>
    <h1>Snake AI: King of the Hill</h1>

    <div id="mainLayout">
        <div id="tournamentSection">
            <div id="controls">
                <div class="control-group">
                    <button id="startTournamentBtn">Start New Tournament</button>
                    <button id="nextBattleBtn" disabled>Next Battle</button>
                    <button id="toggleFullscreenBtn">Toggle Fullscreen</button>
                </div>
                <div class="control-group">
                    <label for="autoBattleCheckbox" style="display: inline-x, current_segment_y = head_pos
        # Try to grow body away from initial direction vector to avoid immediate self-collision if length > 1
        dx_segment_growth = -self.DIRECTIONS_MAP[self.direction_idx][0]
        dy_segment_growth = -self.DIRECTIONS_MAP[self.direction_idx][1]

        for i in range(1, self.length):
            next_segment_x = (current_segment_x + dx_segment_growth + self.grid_width) % self.grid_width
            next_segment_y = (current_segment_y + dy_segment_growth + self.grid_height) % self.grid_height
            
            # Check if the new segment position is already occupied by the head or previous segments
            if (next_segment_x, next_segment_y) in self.positions:
                # print(f"Warning: Snake {self.name} initial body segment overlap at segment {i+1}. Trying alternative growth.")
                # Fallback: try a different direction for segment growth if collision
                # This can happen if initial_length is large relative to grid or snake starts near edge/corner
                found_clear_spot = False
                for alt_dir_idx in range(4): # Try all 4 directions
                    # Skip current growth direction and its opposite
                    if alt_dir_idx == self.direction_idx or alt_dir_idx == self.OPPOSITE_ACTIONS_MAP[self.direction_idx]:
                        continue 
                    
                    alt_dx = -self.DIRECTIONS_MAP[alt_dir_idx][0]
                    alt_dy = -self.DIRECTIONS_MAP[alt_dir_flex; align-items: center; cursor:pointer;">
                        <input type="checkbox" id="autoBattleCheckbox" style="margin-right: 5px;">Auto-Advance
                    </label>
                    <label for="gridWidthInput">Grid W: <input type="number" id="gridWidthInput" value="20" min="10" max="50"></label>
                    <label for="gridHeightInput">Grid H: <input type="number" id="gridHeightInput" value="10" min="5" max="30"></label>
                </div>
                <span id="autoBattleStatus" style="font-size: 0.9em;"></span>
            </div>
            <div id="tournamentInfo">
                <div id="kingInfo">Current King: --- (Reign Wins: 0)</div>
                <div id="aiNames">Player 1: --- vs Player 2: ---</div>
            </div>
            <div id="scores">Score: P1 (0) - P2 (0)</div>
            <canvas id="gameCanvas"></canvas>
            <div id="status">Welcome! Click "Start New Tournament".</div>
            <div id="loadingStatus"></div>
            <div id="errorMessage" class="error-message"></div>
        </div>

        <div id="leaderboardSection">
            <h2>Tournament Leaderboard</h2>
            <div id="leaderboard">
                <p>No tournament data yet.</p>
            </div>
        </div>
    </div>

    <script type="module">
        // --- Game Configuration ---
        let currentGridWidth = 20; // Default, will be updated from input
        let currentGridHeight = 10; // Default, will be updated from input
        const INITIAL_SNAKE_LENGTH = 3;
        let baseCellSize = 28; // Base size for normal view
        let effectiveCellSize = baseCellSize; // Used for actual drawing, changes with fullscreen
        let MAX_STEPS_PER_GAME = currentGridWidth * currentGridHeight * 2;
        const GAME_SPEED_MS = 100;
        const AUTO_BATTLE_DELAY_MS = 3000;

        const SNAKE_1_COLOR = "#2ecc71";
        const SNAKE_1_HEAD_COLOR = "#27ae60";
        const SNAKE_2_COLOR = "#e74c3c";
idx][1]
                    alt_next_segment_x = (current_segment_x + alt_dx + self.grid_width) % self.grid_width
                    alt_next_segment_y = (current_segment_y + alt_dy + self.grid_height) % self.grid_height

                    if (alt_next_segment_x, alt_next_segment_y) not in self.positions:
                        next_segment_x, next_segment_y = alt_next_segment_x, alt_next_segment_y
                        # print(f"Alternative growth successful for segment {i+1} using direction {alt_dir_idx}")
                        found_clear_spot = True
                        break 
                if not found_clear_spot:
                    # print(f"Critical Warning: Snake {self.name} could not place segment {i+1} without overlap. Snake will be shorter.")
                    self.length = i # Adjust actual length
                    break 
            
            self.positions.append((next_segment_x, next_segment_y))
            current_segment        const SNAKE_2_HEAD_COLOR = "#c0392b";
        const FOOD_COLOR = "#f1c40f";
        const GRID_LINE_COLOR = "#7f8c8d";

        // --- Python Game Engine Code ---
        const PYTHON_ENGINE_CODE = `
import random
from collections import deque
from dataclasses import dataclass
from typing import List, Tuple, Optional, Callable 
import traceback 

@dataclass
class Food:
    position: Tuple[int, int]

class Snake:
    DIRECTIONS_MAP = [(0, -1), (1, 0), (0, 1), (-1, 0)] 
    ACTIONS_LIST = [0, 1, 2, 3]
    OPPOSITE_ACTIONS_MAP = {0: 2, 1: 3, 2: 0, 3: 1}

    def __init__(self, x: int, y: int, grid_width: int, grid_height: int, initial_target_length: int,_x, current_segment_y = next_segment_x, next_segment_y
        
    def get_head_position(self) -> Tuple[int, int]:
        return self.positions[0]

    def get_current_direction_vector(self) -> Tuple[int, int]:
        return self.DIRECTIONS_MAP[self.direction_idx]

    def get_valid_actions(self) -> List[int]:
        if not self.is_alive: return []
        if len(self.positions) <= 1: # If snake is just a head, can move any direction
            return list(self.ACTIONS_LIST)
        invalid_action = self.OPPOSITE_ACTIONS_MAP[self.direction_idx]
        return [a for a in self.ACTIONS_LIST if a != invalid_action]

    def move(self, action_idx: int) -> bool: 
        if not self.is_alive: return False

        # Action validation should ideally happen before calling move, or AI should only choose valid ones.
        # If an invalid action (like reverse) is passed, this logic will lead to self-collision.
        self.direction_idx = action_idx
        head_x, head_y = self.get_head_position()
         initial_direction_idx: Optional[int] = None):
        self.grid_width = grid_width
        self.grid_height = grid_height
        
        self.positions = deque()
        self.direction_idx = initial_direction_idx if initial_direction_idx is not None \
                             else random.choice(self.ACTIONS_LIST)
        self.score = 0
        self.is_alive = True
        self.name = "Snake" 

        head_pos = (x,y)
        self.positions.appendleft(head_pos) # Head is at index 0
        
        current_segment_x, current_segment_y = head_pos
        dx_segment_growth = -self.DIRECTIONS_MAP[self.direction_idx][0]
        dy_segment_growth = -dx, dy = self.get_current_direction_vector()
        new_head = ((head_x + dx) % self.grid_width, (head_y + dy) % self.grid_height)

        # Check self-collision: new head collides with any part of the body *except* the current tail tip IF it's going to move
        body_to_check = list(self.positions)
        if len(self.positions) >= self.length: # Tail will move, so don't check collision with it
             self.DIRECTIONS_MAP[self.direction_idx][1]

        for i in range(1, initial_target_length):
            next_segment_x = (current_segment_x + dx_segment_growth + self.grid_width) % self.grid_width
            next_segment_y = (current_segment_y + dy_segment_growth + self.grid_height) % self.grid_height
            
            if (next_segment_x, next_segment_y) in self.positions:
                # print(f"Warning: Snake {self.name} initial body segment overlap at segment {i+1}/{initial_target_length}. Actual length will be shorter.")
                break 
            self.positions.append((nextbody_to_check = body_to_check[:-1]
        
        if new_head in body_to_check:
            self.is_alive = False
            return True # Died by self-collision

        self.positions.appendleft(new_head)
        if len(self.positions) > self.length:
            self.positions.pop()
        return False # Survived move

    def grow(self):
        if not self.is_alive: return
        self.length += 1
        self.score += 1

    def to_dict(self):
        return {
            "positions": list(self.positions),
            "direction_idx": self.direction_idx,
            "length": self.length,
            "score": self.score,
            "is_alive": self.is_alive,
            "name": self.name,
            "grid_width": self.grid_width,
            "grid_segment_x, next_segment_y)) # Append to the tail of the deque
            current_segment_x, current_segment_y = next_segment_x, next_segment_y
        
        self.length = len(self.positions) # CRITICAL: Actual length based on successfully added segments

    def get_head_position(self) -> Tuple[int, int]:
        return self.positions[0]

    def get_current_direction_vector(self) -> Tuple[int, int]:
        return self.DIRECTIONS_height": self.grid_height
        }

def load_ai_function_from_string(python_code_string: str, function_name: str = "get_challenger_action"):
    exec_globals = {
        "Snake": Snake, 
        "Food": Food,   
        "random": random,
        "deque": deque,
        "traceback": traceback
    }
    try:
        exec(python_code_string, exec_globals)
        ai_function = exec_globals.get(_MAP[self.direction_idx]

    def get_valid_actions(self) -> List[int]:
        if not self.is_alive: return []
        if len(self.positions) <= function_name)
        if callable(ai_function):
            return ai_function
        else:
1: # If only head, no opposite action restriction
            return list(self.ACTIONS_LIST)
        invalid_action = self.OPPOSITE_ACTIONS_MAP[self.direction_idx]
        return [a for a            # print(f"Error: AI Function '{function_name}' not found or not callable after exec.")
            # print(f"Available names in AI module after exec: {list(exec_globals.keys())}")
            return None
    except Exception as e:
        print(f"Error executing AI code string: {e}")
        trace in self.ACTIONS_LIST if a != invalid_action]

    def move(self, action_idx: int) -> bool: 
        if not self.is_alive: return False

        # Action validation shouldback.print_exc()
        return None

class SnakeEnvironment:
    def __init__(self, grid_width: int, grid_height: int, initial_snake_length: int, max_steps: int,
                 ai1_logic: Callable, ai2_logic: Callable, 
                 snake1_name ideally be done by AI or environment before calling move
        # If an invalid action (like reverse) is passed, it will likely lead to self-collision
        self.direction_idx = action_idx
        head_x, head_y = self.get_head_position()
        dx, dy = self.get_current_direction: str = "P1", snake2_name: str = "P2"):
        self.grid_width = grid_width
        self.grid_height = grid_height
        self.initial_snake_length = initial_vector()
        new_head = ((head_x + dx) % self.grid_width, (head_y + dy) % self.grid_height)

        body_to_check = list(self_snake_length
        self.max_steps = max_steps
        self.ai1_logic = ai1_logic
        self.ai2_logic = ai2_logic
        self.snake1_name_init = snake1_name
        self.snake2_name_init = snake2_name
        self.reset()

    def reset(self):
        self.steps_taken = 0
        self.game_over = False
        self.winner_snake_obj_ref = None
        self..positions)
        # If snake is at its current 'length', the tail segment will move out of the way.
        # So, for self-collision, don't check against the last segment.
        if len(self.positions) >= self.length: 
            body_to_check = body_to_check[:-1] 
        
        if new_head in body_to_check:
            self.is_alive = False
            return True # Died by self-collision

        self.positions.appendleft(new_head)
winner_message = ""
        
        # Ensure initial length is not greater than grid area
        safe_initial_length = min(self.initial_snake_length, (self.grid_width * self.grid_height) // 2 -1) # Heuristic
        if safe_initial_length <=0: safe_initial_length = 1


        s1_x, s1_y = self.grid_width // 4, self.grid_height // 2
        s1_dir = 1 # Right
        self.snake1 =        if len(self.positions) > self.length: # If not grown, remove tail
            self.positions.pop()
        return False # Survived move

    def grow(self):
        if not self.is_alive: return
        self.length += 1
        self.score += 1

    def to_dict(self):
        return {
            "positions": list(self.positions),
            "direction_idx": self.direction_idx,
            "length": self.length,
            "score": Snake(s1_x, s1_y, self.grid_width, self.grid_height, safe_initial_length, initial_direction_idx=s1_dir)
        self.snake1.name = self.snake1_name_init

        s2_x, s2_y = self.grid_width * 3 // 4, self.grid_height // 2
        s2_dir = 3 # Left
        self.snake2 = Snake(s2_x, s2_y, self.grid self.score,
            "is_alive": self.is_alive,
            "name": self.name,
            "grid_width": self.grid_width,
            "grid_height": self.grid_height
        }

def load_ai_function_from_string(python_code_string: str, function_name: str = "get_challenger_action"):
    exec_globals = {
        "Snake": Snake, "Food": Food, "random": random, "deque": deque, "traceback": traceback
    }
    try:
        exec(python_code_string, exec_globals)
        ai_function = exec_width, self.grid_height, safe_initial_length, initial_direction_idx=s2_dir)
        self.snake2.name = self.snake2_name_init

        # Basic check for immediate overlap of heads (body overlap handled by Snake init)
        if self.snake1.get_head_position() == self.snake2.get_head_position():
            # print("Initial snake head overlap detected, attempting to adjust s2.")
            # Try moving s2 one step in its initial direction if possible, or a different spot
            s2_new_y = (s2_y + 1) % self.grid_height
            _globals.get(function_name)
        if callable(ai_function): return ai_function
        else:
            print(f"Error: AI Function '{function_name}' not found or not callable after exec.")
            return None
    except Exception as e:
        print(f"Error executing AI code string: {e}")
        traceback.print_exc()
        return None

class SnakeEnvironment:
    def __init__(self, grid_widthif s2_new_y == s1_y and s2_x == s1_x : # if still overlap after simple y shift
                 s2_new_y = (s2_y - 1 + self.grid_height) % self.grid_height # try y-1
            
            self.snake2 = Snake(s2_x, s2_new_y, self.grid_width, self.: int, grid_height: int, initial_snake_length: int, max_steps: int,
                 ai1_logic: Callable, ai2_logic: Callable, 
                 snake1_name: str = "P1", snake2_name: str = "P2"):
        self.grid_width = grid_width
        self.grid_height = grid_height
        self.initial_snake_length = initial_snake_length
        self.max_steps = max_steps
        self.ai1_logic = ai1_logic
        self.ai2_logic = ai2_logic
        self.snake1_name_init = snake1_name
        self.snake2_name_init = snake2_name
        self.reset()

    def reset(self):
        self.steps_taken = 0
        self.game_over = False
        self.winner_snake_obj_ref = None
        selfgrid_height, safe_initial_length, initial_direction_idx=s2_dir)
            self.snake2.name = self.snake2_name_init
            if self.snake1.get_head_position() == self.snake2.get_head_position():
                 # print("Head overlap still present after adjustment. This might lead to issues.")
                 pass # Further adjustments could be complex, rely on game resolving it

        self.foods = []
        self._spawn_food() 
        self._spawn_food() 

    def _spawn_food(self):
        if len(self.foods) >= 2: return 

        occupied_cells = set()
        if self.snake1 and self.snake1.is_alive: occupied_cells.update(self.snake1.positions)
        if self.snake2 and self.snake2.is_alive: occupied_cells.update(self.snake2.positions)
        for food_item.winner_message = ""
        
        s1_x, s1_y = max(0, self.grid_width // 4), max(0, self.grid_height // 2)
        s1_dir = 1 
        self.snake1 = Snake(s1_x, s1_y, self.grid_width, self.grid_height, self.initial_snake_length, initial_direction_idx=s1_dir)
        self.snake1.name = self.snake1_name_init

        s2_x, s2_y = max(0, self.grid_width * 3 // 4), max(0, self.grid_height // 2)
        s2_dir = 3 
        self.snake2 = Snake(s2_x, s2_y, self.grid_width, self.grid_height, self.initial_snake_length, initial_direction_idx=s2_dir)
        self.snake2.name = self.snake2_name_init

        if any(p in self.snake in self.foods: occupied_cells.add(food_item.position)
        
        empty_cells = [(x, y) for x in range(self.grid_width) for y in range(self.grid_height) if (x,y) not in occupied_cells]
        if empty_cells:
            self.foods.append(Food(random.choice(empty_cells)))

    def _get_actions_from_ais(self):
        action1 = self.snake1.direction_idx if self.snake1 else 0
        action2 = self.snake2.direction_idx if self.snake2 else 0
        
        foods_for_ai = list(self.foods)

        if self.snake1 and self.snake1.is_alive:
            valid_actions1 = self.snake1.get_valid_actions()
            if valid_actions1:
                try:
                    opponent_s1 = self.snake1.positions for p in self.snake2.positions) or \
           any(p in self.snake2.positions for p in self.snake1.positions):
            # print("Initial snake overlap detected, attempting to adjust s2.")
            alt_s2_y = (s2_y + 1) % self.grid_height if s2_y + 1 != s1_y else (s2_y - 1 + self.grid_height) % self.grid_height
            self.snake2 = Snake(s2_x, alt_s2_y , self.grid_width, self.grid_height, self.initial_snake_length, initial_direction_idx=s2_dir)
            self.snake2.name = self.snake2_name_init
            # if any(p in self.snake1.positions for p in self.2 if self.snake2 and self.snake2.is_alive else None
                    act1_candidate = self.ai1_logic(self.snake1, opponent_s1, foods_for_ai, self.grid_width, self.grid_height)
                    action1 = act1_candidate if act1_candidate in valid_actions1 else random.choice(valid_actions1)
                except Exception as e:
                    # print(f"Error in AI1 ({self.snake1.name}) logic: {e}. Choosing random valid action.")
                    # traceback.print_exc()
                    action1 = random.choice(valid_actions1)
        
        if self.snake2 and self.snake2.is_alive:
            valid_actions2 = self.snake2.get_valid_actions()
            if valid_actions2:
                try:
                    opponent_s2 = self.snake1 if self.snake1 and self.snake1.issnake2.positions):
                 # print("Overlap still present after adjustment.")

        self.foods = []
        self._spawn_food() 
        self._spawn_food() 

    def _spawn_food(self):
        if len(self.foods) >= 2: return 
        occupied_cells = set()
        if self.snake1 and self.snake1.is_alive: occupied_cells.update(self.snake1.positions)
        if self.snake2 and self.snake2.is_alive: occupied_cells.update(self.snake2.positions)
        for food_item in self.foods: occupied_cells.add(food_item.position)
        
        empty_cells = [(x, y) for x in range(self.grid_width) for y in range(self.grid_height) if (x,y) not in occupied_cells]
        if empty_cells:
            self.foods.append(Food(random.choice(empty_cells)))

    def _get_actions_from_ais(self):
        _alive else None
                    act2_candidate = self.ai2_logic(self.snake2, opponent_s2, foods_for_ai, self.grid_width, self.grid_height)
                    action2 = act2_candidate if act2_candidate in valid_actions2 else random.choice(valid_actions2)
                except Exception as e:
                    # print(f"Error in AI2 ({self.snake2.name}) logic: {e}. Choosing random valid action.")
                    # traceback.print_exc()
                    action2 = random.choice(valid_actions2)
        return action1, action2

    def run_step(self):
        if self.game_over:
            return self.get_state()

        action1, action2 = self._get_actions_from_ais()
        self.steps_taken += 1

        s1_died_self = self.snake1.move(action1) if self.snake1 and self.snake1.is_alive else False
        s2_died_self = selfaction1 = self.snake1.direction_idx if self.snake1 else 0
        action2 = self.snake2.direction_idx if self.snake2 else 0
        foods_for_ai = list(self.foods)

        if self.snake1 and self.snake1.is_alive:
            valid_actions1 = self.snake1.get_valid_actions()
            if valid_actions1:
                try:
                    opponent_s1 = self.snake2 if self.snake2 and self.snake2.is_alive else None
                    act1_candidate = self.ai1_logic(self.snake1, opponent_s1, foods_for_ai, self.grid_width, self.grid_height)
                    action1 = act1_candidate if act1_candidate in valid_actions1 else random.choice(valid_actions1)
                except Exception as e:
                    # print(f"Error in AI1 ({self.snake1.name}) logic: {e}. Choosing random.")
                    # traceback.print_exc() #.snake2.move(action2) if self.snake2 and self.snake2.is_alive else False
        
        s1_hit_s2_body, s2_hit_s1_body = False, False
        head_on_collision_s1_dies, head_on_collision_s2_dies = False, False

        if self.snake1.is_alive and self.snake2.is_alive:
            h1_pos, h2_pos = self.snake1.get_head_position(), self.snake2.get_head_position()
            
            if h1_pos == h2_pos: 
                if self.snake1.length > self.snake2.length: head_on_collision_s2_dies = True
                elif self.snake2.length > self.snake1.length: head_on_collision_s1_dies = True
                else: head_on_collision_s1_dies, head_on_collision_s2_dies = True, True
            else:
 This can be very verbose in browser console
                    action1 = random.choice(valid_actions1)
        
        if self.snake2 and self.snake2.is_alive:
            valid_actions2 = self.snake2.get_valid_actions()
            if valid_actions2:
                try:
                    opponent_s2 = self.snake1 if self.snake1 and self.snake1.is_alive else None
                    act2_candidate = self.ai2_logic(self.snake2, opponent_s2, foods_for_ai, self.grid_width, self.grid_height)
                    action2 = act2_candidate if act2_candidate in valid_actions2 else random.choice(valid_actions2)
                except Exception as e:
                    # print(f"Error in AI2 ({self.snake2.name}) logic: {e}. Choosing random.")
                    # traceback.print_exc()
                    action2 = random.choice(valid_actions2)
        return action1, action2

    def run_step                if h1_pos in list(self.snake2.positions)[1:]: s1_hit_s2_body = True
                if h2_pos in list(self.snake1.positions)[1:]: s2_hit_s1_body = True
        
        if s1_died_self or head_on_collision_s1_dies or s1_hit_s2_body: self.snake1.is_alive = False
        if s2_died_self or head_on_collision_s2_dies or s2_hit_s1_body: self.snake2.is_alive = False
        
        food_eaten_indices = []
        if self.snake1.is_alive:
            s1_head = self.snake1.get_head_position()
            for i, food in enumerate(self.foods):
                if s1_head == food.position:
                    self.snake1.grow(); food_eaten_indices.append(i); break 
        
        if self.snake2.is_alive:
            s2_head = self.snake2.get_head_position()(self):
        # ... (rest of run_step is largely the same as your V2, ensure it uses self.snake1/2 correctly) ...
        if self.game_over:
            return self.get_state()

        action1, action2 = self._get_actions_from_ais()
        self.steps_taken += 1

        s1_died_self = self.snake1.move(action1) if self.snake1 and self.snake1.is_alive else False
        s2_died_self = self.snake2.move(action2) if self.snake2 and self.snake2.is_alive else False
        
        s1_hit_s2_body, s2_hit_s1_body = False, False
        head_on_collision_s1_dies, head_on_collision_s2_dies = False, False

        if self.snake1.is_alive and self.snake2.is_alive:
            h1_pos, h2_pos = self.snake1.get_head_position(),
            for i, food in enumerate(self.foods):
                if i in food_eaten_indices: continue 
                if s2_head == food.position:
                    self.snake2.grow(); food_eaten_indices.append(i); break 
        
        if food_eaten_indices:
            for i in sorted(food_eaten_indices, reverse=True): del self.foods[i]
            for _ in range(len(food_eaten_indices)): self._spawn_food()

        s1_alive = self.snake1 and self.snake1.is_alive
        s2_alive = self.snake2 and self.snake self.snake2.get_head_position()
            
            if h1_pos == h2_pos: 
                if self.snake1.length > self.snake2.length: head_on_collision_s2_dies = True
                elif self.snake2.length > self.snake1.length: head_on_collision_s1_dies = True
                else: head_on_collision_s1_dies, head_on_collision_s2_dies = True, True 
            else:
                if h1_pos in list(self.snake2.positions)[1:]: s1_hit_s2_body = True
                if h2_pos in list(self.snake1.positions)[1:]: s2_hit_s1_body = True
        
        if s1_died_self or head_on_collision_s1_dies or s1_hit_s2_body: self.snake1.is_2.is_alive

        if not s1_alive and not s2_alive:
            self.game_over = True
            if self.snake1.score > self.snake2.score: self.winner_message = f"{self.snake1.name} wins by score! (Both eliminated)"; self.winner_snake_obj_ref = self.snake1
            elif self.snake2.score > self.snake1.score: self.winner_message = f"{self.snake2.name} wins by score! (Both eliminated)"; self.winner_snake_obj_ref = self.snake2
            else: self.winner_message = "Draw! (Both eliminated, same score)"
        elif not s1_alive: self.game_over = True; self.winner_message = f"{self.snake2.name} wins! ({self.snake1.name} eliminated)"; self.winner_snake_obj_ref = self.snake2
        elif not s2_alive: self.game_over = True; self.winner_message = f"{self.snake1.name} wins! ({self.snake2.name} eliminated)"; self.winner_snake_obj_ref = self.snake1
        elif self.steps_taken >= self.max_steps:
            self.game_over = True
            if self.snake1.score > self.snake2.alive = False
        if s2_died_self or head_on_collision_s2_dies or s2_hit_s1_body: self.snake2.is_alive = False
        
        food_eaten_indices = []
        if self.snake1.is_alive:
            s1_head = self.snake1.get_head_position()
            for i, food in enumerate(self.foods):
                if s1_head == food.position:
                    self.snake1.grow(); food_eaten_indices.append(i); break 
        
        if self.snake2.is_alive:
            s2_head = self.snake2.get_head_position()
            for i, food in enumerate(self.foods):
                if i in food_eaten_indices: continue 
                if s2_head == food.position:
                    self.snake2.grow(); food_eaten_indices.append(i); break 
        
        if food_eaten_indices:
            for i in sorted(food_eaten_indices, reverse=True): del self.foods[i]
            for _ in rangescore: self.winner_message = f"{self.snake1.name} wins by score! (Max steps)"; self.winner_snake_obj_ref = self.snake1
            elif self.snake2.score > self.snake1.score: self.winner_message = f"{self.snake2.name} wins by score! (Max steps)"; self.winner_snake_obj_ref = self.snake2
            elif self.snake1.length > self.snake2.length: self.winner_message = f"{self.snake1.name} wins by length! (Max steps, same score)"; self.winner_snake_obj_ref = self.snake1
            elif self.snake2.length > self.snake1.length: self.winner_message = f"{self.snake2.name} wins by length! (Max steps, same score)"; self.winner_snake_obj_ref = self.snake2
            else: self.winner_message = "Draw! (Max steps, same score & length)"
        
        if not self.foods and (s1_alive or s2_alive) and not self.game_over : self._spawn_food()

        return self.get_state()

    def get_state(self):
        winner_name = self.winner_snake_obj_ref.name if self.winner_snake_obj_ref else None
        (len(food_eaten_indices)): self._spawn_food()

        s1_alive = self.snake1 and self.snake1.is_alive
        s2_alive = self.snake2 and self.snake2.is_alive

        if not s1_alive and not s2_alive:
            self.game_over = True
            if self.snake1.score > self.snake2.score: self.winner_message = f"{self.snake1.name} wins by score! (Both eliminated)"; self.winner_snake_obj_ref = self.snake1
            elif self.snake2.score > self.snakereturn {"snake1": self.snake1.to_dict() if self.snake1 else None, "snake2": self.snake2.to_dict() if self.snake2 else None,
                "foods": [food.position for food in self.foods], "game_over": self.game_over, "steps_taken": self.steps_taken,
                "grid_width": self.grid_width, "grid_height": self.grid_height, "winner_message": self.winner_message, "winner_name": winner_name}

print("Python Snake Game Engine (for Web/Pyodide) Loaded. V3")
`;

        // --- UI Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startTournamentBtn = document.getElementById('startTournamentBtn');
        const nextBattleBtn = document.getElementById('nextBattleBtn');
        const autoBattleCheckbox = document.getElementById('autoBattleCheckbox');
        const autoBattleStatusSpan = document.getElementById('autoBattleStatus');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const applyConfigBtn = document.getElementById('applyConfigBtn');
        
        const gridWidthInput = document.getElementById('gridWidthInput');
        const gridHeightInput = document.getElementById('gridHeightInput');
        1.score: self.winner_message = f"{self.snake2.name} wins by score! (Both eliminated)"; self.winner_snake_obj_ref = self.snake2
            else: self.winner_message = "Draw! (Both eliminated, same score)"
        elif not s1_alive: self.game_over = True; self.winner_message = f"{self.snake2.name} wins! ({self.snake1.name} eliminated)"; self.winner_snake_obj_ref = self.snake2
        elif not s2_alive: self.game_over = True; self.winner_message = f"{self.snake1.name} wins! ({self.snake2.name} eliminated)"; self.winner_snake_obj_ref = self.snake1
        elif self.steps_taken >= self.max_steps:
            self.game_over = True
            if self.snake1.score > self.snake2.score: self.winner_message = f"{self.snake1.name} wins by score! (Max steps)"; self.winner_snake_obj_ref = self.snake1
            elif self.snake2.score > self.snake1.score: self.winner_message = f"{self.snake2.name} wins by score! (Max steps)"; self.winner_snake_obj_ref = self.snake2
            elif self.snake1.length > self.snake2.length: self.winner_message = f"{self.snake1.name} wins by length! (Max steps, same score)"; self.winner_snake_obj_ref = self.snake1
            elif self.snake2.length > self.snake1.length: self.winner_message = f"{self.snake2.name} wins by length! (Max steps, same score)"; self.winner_snake_obj_ref = self.snake2
            else: self.winner_message = "Draw! (Max steps, same score & length)"
        
        if not self.foods and (s1_alive or s2_alive) and len(self.foods) < 2 : self._spawn_food()
        return self.get_state()

    def get_state(self):
        # ... (getconst cellSizeInput = document.getElementById('cellSizeInput');
        const initialSnakeLengthInput = document.getElementById('initialSnakeLengthInput');

        const statusDiv = document.getElementById('status');
        const scoresDiv = document.getElementById('scores');
        const aiNamesDiv = document.getElementById('aiNames');
        const kingInfoDiv = document.getElementById('kingInfo');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const errorMessageDiv = document.getElementById('errorMessage');
        const leaderboardDiv = document.getElementById('leaderboard');

        // --- Pyodide and Game State ---
        let pyodide = null;
        let pyGameEnv = null;
        let championsList = []; 
        let gameLoopInterval = null;
        let_state is largely the same as your V2) ...
        winner_name = self.winner_snake_obj_ref.name if self.winner_snake_obj_ref else None
        return {
            "snake1": self.snake1.to_dict() if self.snake1 else None,
            "snake2": self.snake2.to_dict() if self.snake2 else None,
            "foods": [food.position for food in self.foods],
            "game_over": self.game_over,
            "steps_taken": self.steps_taken,
            "grid_width": self.grid_width,
            "grid_height": self.grid_height,
            "winner_message": self.winner_message,
            "winner_name": winner_name
        }

print("Python Snake Game Engine (for Web/Pyodide) Loaded. V3")
`;

        // --- UI Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startTournamentBtn = document.getElementById('startTournamentBtn');
        const nextBattleBtn = document.getElementById('nextBattleBtn');
        const toggleFullscreenBtn = document.getElementById('toggleFullscreenBtn');
        const autoBattleCheckbox = document.getElementById('autoBattleCheckbox');
        const gridWidthInput = document.getElementById('gridWidthInput');
        const gridHeightInput = document.getElementById('gridHeightInput');
        const autoBattleStatusSpan = document.getElementById('autoBattleStatus');
        const statusDiv = document.getElementById('status');
        const scoresDiv = isLoading = false; // True if Pyodide/AI loading or battle setup is in progress
        let autoBattleTimeoutId = null;

        // --- Tournament State ---
        let currentKing = null; 
        let activeP1 = null; 
        let activeP2 = null; 

        // --- Helper Functions ---
        function showError(message) { errorMessageDiv.textContent = message; console.error(message); }
        function showLoadingStatus(message) { loadingStatusDiv.textContent = message; }
        function clearMessages() { errorMessageDiv.textContent = ''; }
        function updateKingDisplay() { /* ... (unchanged) ... */ }
        function updateLeaderboard() { /* ... (unchanged) ... */ }
        
        function applyCurrentConfig() {
            GRID_WIDTH = parseInt(gridWidthInput.value) || 20;
            GRID_HEIGHT = parseInt(gridHeightInput.value) || 10;
            CELL_SIZE = parseInt(cellSizeInput.value) || 28;
            INITIAL_SNAKE_LENGTH = parseInt(initialSnakeLengthInput.value) || 3;

            // Basic validation
            if (GRID_WIDTH < 10) GRID_WIDTH = 10;
            if (GRID_HEIGHT < 10) GRID_HEIGHT = 10;
            if (CELL_SIZE < 5) CELL_SIZE = 5;
            if (INITIAL_SNAKE_LENGTH < 1) INITIAL_SNAKE_LENGTH = 1;
            if (INITIAL_SNAKE_LENGTH >= (GRID_WIDTH * GRID_HEIGHT) / 2) { // Heuristic
                INITIAL_SNAKE_LENGTH = Math.max(1, Math.floor((GRID_WIDTH * GRID_HEIGHT) / 3));
                showError(`Initial snake length too large for grid, adjusted to ${INITIAL_SNAKE_LENGTH}`);
            }
            
            gridWidthInput.value = GRID_WIDTH;
            gridHeightInput.value = GRID_HEIGHT;
            cellSizeInput.value = CELL_SIZE;
            initialSnakeLengthInput.value = INITIAL_SNAKE_LENGTH;

            canvas.width = GRID_WIDTH * CELL_SIZE;
            canvas.height = GRID_HEIGHT * CELL_SIZE;
            MAX_STEPS_PER_GAME = GRID_WIDTH * GRID_HEIGHT * document.getElementById('scores');
        const aiNamesDiv = document.getElementById('aiNames');
        const kingInfoDiv = document.getElementById('kingInfo');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const errorMessageDiv = document.getElementById('errorMessage');
        const leaderboardDiv = document.getElementById('leaderboard');

        // --- Pyodide and Game State ---
        let pyodide = null;
        let pyGameEnv = null;
        let championsList = [];
        let gameLoopInterval = null;
        let isLoading = false;
        let autoBattleTimeoutId = null;
        let currentGameStateForRender = null; // Store last known game state for re-renders

        // --- Tournament State ---
        let currentKing = null;
        let activeP1 = null;
        let activeP2 = null;

        // --- Canvas Setup ---
        function updateCanvasDimensionsAndClear() {
            canvas.width = currentGridWidth * effectiveCellSize;
            canvas.height = currentGridHeight * effectiveCellSize;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // console.log(`Canvas updated: ${canvas.width}x${canvas.height}, effectiveCellSize: ${effectiveCellSize}`);
        }
        // Initial setup call
        updateCanvasDimensionsAndClear();


        // --- Helper Functions ---
        function showError(message) { errorMessageDiv.textContent = message; console.error(message); }
        function showLoadingStatus(message) { loadingStatusDiv.textContent = message; }
        function clearMessages() { errorMessageDiv.textContent = ''; }
        function updateKingDisplay() { /* ... ( 2; // Recalculate
            console.log(`Applied config: ${GRID_WIDTH}x${GRID_HEIGHT}, Cell:${CELL_SIZE}, Len:${INITIAL_SNAKE_LENGTH}, MaxSteps:${MAX_STEPS_PER_GAME}`);
        }


        // --- Pyodide Initialization ---
        async function initPyodide() { /* ... (unchanged) ... */ }

        // --- Champion Loading ---
        async function loadChampionsManifest() { /* ... (unchanged) ... */ }
        async function loadAIFunctionIfNeeded(aiInfo) { /* ... (unchanged) ... */ }

        // --- Drawing Functions ---
        function drawGrid() { /* ... (unchanged, currently not called) ... */ }
        function drawSnake(snakeData, color, headColor) { /* ... (unchanged) ... */ }
        function drawFoods(foodsList) { /* ... (unchanged) ... */ }
        function renderGame(gameState) { /* ... (unchanged) ... */ }

        // --- Game Loop ---
        function gameStep() {
            if (!pyGameEnv) return; // Should not happen if loop is running

            try {
                const rawState = pyGameEnv.run_step();
                const gameState = rawState.toJs({ dict_converter: Object.fromEntries, create_proxies: false }); 
                rawState.destroy(); 

                renderGame(gameState);

                if (gameState.game_over) {
                    clearInterval(gameLoopInterval);
                    gameLoopInterval = null;
                    // isLoading is forsame as V2) ... */
            if (currentKing) {
                kingInfoDiv.textContent = `Current King: ${currentKing.name} (Reign Wins: ${currentKing.currentReignWins})`;
            } else {
                kingInfoDiv.textContent = "Current King: --- (Reign Wins: 0)";
            }
        }
        function updateLeaderboard() { /* ... (same as V2) ... */
            if (championsList.length === 0) {
                leaderboardDiv.innerHTML = "<p>No champions loaded.</p>";
                return;
            }
            const sortedChampions = [...championsList].sort((a, b) => {
                if (b.totalTournamentWins !== a.totalTournamentWins) {
                    return b.totalTournamentWins - a.totalTournamentWins;
                }
                return a.name.localeCompare(b.name);
            });

            leaderboardDiv.innerHTML = sortedChampions.map(champ => `
                <div class="leaderboard-item">
                    <span class="leaderboard-name">${champ.name}</span>
                    <span class.leaderboard-wins">${champ.totalTournamentWins} wins</span>
                </div>
            `).join('');
            if (sortedChampions.length === 0) {
                 leaderboardDiv.innerHTML = "<p>No tournament data yet.</p>";
            }
        }

        // --- Pyod setup, not for game running state.
                    autoBattleStatusSpan.textContent = "";

                    let battleOutcomeMessage = "";
                    // ... (winner processing logic - unchanged) ...
                    if (gameState.winner_name) {
                        const winnerObject = (gameState.winner_name === activeP1.name) ? activeP1 : activeP2;
                        if (winnerObject) { 
                            winnerObject.totalTournamentWins++;
                            if (!currentKing) { 
                                currentKing = winnerObject;
                                currentKing.currentReignWins = 1;
                                battleOutcomeMessage = ` ${currentKing.name} is the first King!`;
                            } else { 
                                if (winnerObject === currentKing) { 
                                    currentKing.currentReignWins++;
                                    battleOutcomeMessage = ` ${currentKing.name} remains King!`;
                                } else { 
                                    currentKing.currentReignWins = 0; 
                                    currentKing = winnerObject; 
                                    currentKing.currentReignWins = 1;
                                    battleOutcomeMessage = ` New King: ${currentKing.name}!`;
                                }
                            }
                        } else { battleOutcomeMessage = ` Winner ${gameState.winner_name} not resolved.`; }
                    } else { 
                        battleOutcomeMessage = " Itide Initialization ---
        async function initPyodide() { /* ... (same as V2) ... */
            if (pyodide) return pyodide;
            isLoading = true;
            startTournamentBtn.disabled = true;
            nextBattleBtn.disabled = true;
            autoBattleCheckbox.disabled = true;
            toggleFullscreenBtn.disabled = true;
            showLoadingStatus("Loading Pyodide runtime...");
            try {
                pyodide = await loadPyodide();
                showLoadingStatus("Pyodide loaded. Loading Python game engine...");
                await pyodide.runPythonAsync(PYTHON_ENGINE_CODE);
                showLoadingStatus("Python game engine ready.");
                return pyodide;
            } catch (error) {
                showError(`Pyodide initialization failed: ${error}`);
                throw error;
            } finally {
                isLoading = false;
                toggleFullscreenBtn.disabled = false; 
            }
        }

        // --- Champion Loading ---
        async function loadChampionsManifest() { /* ... (same as V2) ... */
            showLoadingStatus("Fetching champion list...");
            try {
                const response = await fetch('./past_champions/champions_manifest.json');
                if (!response.ok) {
                    throw new Error(`Failed to's a draw!";
                        if (currentKing) { battleOutcomeMessage += ` ${currentKing.name} remains King.`; } 
                        else { battleOutcomeMessage += " No king decided yet."; }
                    }
                    statusDiv.textContent = `Game Over! ${gameState.winner_message || "No winner."}${battleOutcomeMessage}`;
                    updateKingDisplay();
                    updateLeaderboard();
                    
                    const canContinue = (currentKing && championsList.filter(c => c.name !== currentKing.name).length > 0) || (!currentKing && championsList.length >=2);

                    if (autoBattleCheckbox.checked && canContinue) {
                        autoBattleStatusSpan.textContent = `Next battle in ${AUTO_BATTLE_DELAY_MS/1000}s...`;
                        nextBattleBtn.disabled = true;
                        startTournamentBtn.disabled = true; // Keep disabled during auto-battle sequence
                        autoBattleTimeoutId = setTimeout(() => {
                             if (autoBattleCheckbox.checked) { setupAndStartBattle(); } 
                             else {
                                nextBattleBtn.disabled = !canContinue;  fetch champions_manifest.json: ${response.statusText}`);
                }
                const rawList = await response.json();
                if (!Array.isArray(rawList)) {
                     throw new Error("Champions manifest is not a valid JSON array.");
                }
                championsList = rawList.map(champ => ({ 
                    name: champ.name, 
                    file: champ.file, 
                    pyFunc: null, 
                    totalTournamentWins: 0,
                    currentReignWins: 0 
                }));
                
                if (championsList.length < 2) {
                    showError(`Not enough champions (found ${championsList.length}, need at least 2). Tournament cannot start.`);
                    updateLeaderboard(); 
                    return false;
                }
                showLoadingStatus(`Found ${championsList.length} champions. Ready for tournament!`);
                updateLeaderboard();
                return true;
            } catch (error) {
                showError(`Error loading champions: ${error}`);
                championsList = [];
                updateLeaderboard();
                return false;
            }
        }
        async function loadAIFunctionIfNeeded(aiInfo) { /*
                                startTournamentBtn.disabled = false;
                                autoBattleStatusSpan.textContent = "";
                             }
                        }, AUTO_BATTLE_DELAY_MS);
                    } else {
                        nextBattleBtn.disabled = !canContinue;
                        startTournamentBtn.disabled = false;
                        autoBattleCheckbox.disabled = !canContinue;
                        if (!canContinue && currentKing) {
                            statusDiv.textContent += ` King ${currentKing.name} has defeated all challengers! Tournament Over.`;
                            showLoadingStatus("Ultimate Champion crowned!");
                        }
                    }
                } else { // Game not over, update status
                     statusDiv.textContent = `Step: ${gameState.steps_taken || 0} / ${MAX_STEPS_PER_GAME}`;
                }
            } catch (error) {
                showError(`Error during game step: ${error}`);
                console.error("Detailed game step error:", error);
                clearInterval(gameLoopInterval);
                gameLoopInterval = null;
                startTournamentBtn.disabled = false;
                nextBattleBtn.disabled = true; 
                autoBattleCheckbox.disabled = false;
                autoBattleStatusSpan.textContent = "";
            }
        }

         ... (same as V2, ensure Python console output is checked for AI load errors) ... */
            if (aiInfo.pyFunc) return aiInfo.pyFunc;

            showLoadingStatus(`Loading AI: ${aiInfo.name}...`);
            try {
                const response = await fetch(`./past_champions/${aiInfo.file}`);
                if (!response.ok) throw new Error(`Failed to fetch AI file ${aiInfo.file}: ${response.statusText}`);
                const aiCode = await response.text();
                
                if (!pyodide || !pyodide.globals.get('load_ai_function_from_string')) {
                     await initPyodide(); 
                }
                const pyLoaderFunc = pyodide.globals.get('load_ai_function_from_string');
                if (!pyLoaderFunc){
                    throw new Error("Python function 'load_ai_function_from_string' not available.");
                }

                const pyAIFunction = pyLoaderFunc(aiCode); // This now returns None on Python error
                ifasync function setupAndStartBattle() {
            clearMessages();
            if (isLoading) { showError("Previous operation still in progress."); return; }
            if (gameLoopInterval) { clearInterval(gameLoopInterval); gameLoopInterval = null; }
            if (autoBattleTimeoutId) { clearTimeout(autoBattleTimeoutId); autoBattleTimeoutId = null; autoBattleStatusSpan.textContent = ""; }

            isLoading = true;
            startTournamentBtn.disabled = true;
            nextBattleBtn.disabled = true;
            autoBattleCheckbox.disabled = true;
            statusDiv.textContent = "Setting up new battle...";

            try {
                if (!pyodide) await initPyodide();
                if (championsList.length === 0) {
                    const manifestLoaded = await loadChampionsManifest();
                    if (!manifestLoaded || championsList.length < 2) {
                         showError("Cannot start: Not enough champions (need at least 2).");
                         throw new Error("Insufficient champions."); // Caught by local catch
                    }
                }

                let player1AI, player2AI;
                // ... (player selection logic - unchanged) ...
                if (!currentKing) { 
                    if (championsList.length < 2 (!pyAIFunction) { // Check if pyAIFunction is null or undefined
                    // The Python side (load_ai_function_from_string) already prints detailed errors
                    throw new Error(`Could not load AI function from ${aiInfo.file}. Check Python console output for details.`);
                }
                aiInfo.pyFunc = pyAIFunction;
                showLoadingStatus(`AI ${aiInfo.name} loaded.`);
                return pyAIFunction;
            } catch (error) {
                showError(`Error loading AI ${aiInfo.name} (${aiInfo.file}): ${error.message}`);
                // console.error("Detailed AI loading error:", error, "AI Info:", aiInfo); // Redundant if Python prints
                throw error; // Re-throw to be caught by setupAndStartBattle
            }
        }

        // --- Drawing Functions (now use effectiveCellSize) ---
        function drawGrid() {
            ctx.strokeStyle = GRID_LINE_COLOR;
            ctx.lineWidth = 0.5;
            for (let x = 0; x <= currentGridWidth;) { showError("Need at least 2 champions for the first battle."); throw new Error("Insufficient champions for first battle.");}
                    let shuffledChamps = [...championsList].sort(() => 0.5 - Math.random());
                    player1AI = shuffledChamps[0]; player2AI = shuffledChamps[1];
                } else { 
                    player1AI = currentKing;
                    let availableChallengers = championsList.filter(c => c.name !== currentKing.name);
                    if (availableChallengers.length === 0) {
                        showError(`King ${currentKing.name} has defeated all challengers! Tournament ends.`);
                        statusDiv.textContent = `King ${currentKing.name} is the Ultimate Champion!`;
                        throw new Error("Tournament ended, king defeated all."); // Caught by local catch to reset buttons
                    }
                    player2AI = availableChallengers[Math.floor(Math.random() * availableChallengers.length)];
                }
 x++) {
                ctx.beginPath();
                ctx.moveTo(x * effectiveCellSize, 0);
                ctx.lineTo(x * effectiveCellSize, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= currentGridHeight; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * effectiveCellSize);
                ctx.lineTo(canvas.width, y * effectiveCellSize);
                ctx.stroke();
            }
        }

        function drawSnake(snakeData, color, headColor) {
            if (!snakeData || !snakeData.is_alive || !snakeData.positions) return;
            snakeData.positions.forEach((pos, index) => {
                const [x, y] = pos; 
                ctx.fillStyle = (index === 0) ? headColor : color;
                ctx.fillRect(x * effectiveCellSize, y * effectiveCellSize, effectiveCellSize, effective                activeP1 = player1AI; activeP2 = player2AI;

                statusDiv.textContent = `Loading AIs: ${activeP1.name} vs ${activeP2.name}`;
                const pyAI1Func = await loadAIFunctionIfNeeded(activeP1);
                const pyAI2Func = await loadAIFunctionIfNeeded(activeP2);

                if (!pyAI1Func || !pyAI2Func) { throw new Error("One or both AI functions failed to load."); }
                
                const PySnakeEnvironment = pyodide.globals.get('SnakeEnvironment');
                if (!PySnakeEnvironment) { throw new Error("Python class 'SnakeEnvironment' not found."); }

                // Ensure current config values are used
                console.log(`Starting battle with: W:${GRID_WIDTH}, H:${GRID_HEIGHT}, Len:${INITIAL_SNAKE_LENGTH}, MaxSteps:${MAX_CellSize);
            });
        }

        function drawFoods(foodsList) {
            if (!foodsList) return;
            foodsList.forEach(foodPos => {
                const [x, y] = foodPos;
                ctx.fillStyle = FOOD_COLOR;
                ctx.beginPath();
                ctx.arc(x * effectiveCellSize + effectiveCellSize / 2, y * effectiveCellSize + effectiveCellSize / 2, effectiveCellSize / 2.8, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        function renderGame(gameState) {
            if (!gameState) {
                // console.warn("renderGame called with null gameState");
                updateCanvasDimensionsAndClear(); // Ensure canvas is clear if no state
                return;
            }
            currentGameStateForRender = gameState; // Cache for re-renders (STEPS_PER_GAME}`);
                pyGameEnv = PySnakeEnvironment(
                    GRID_WIDTH, GRID_HEIGHT, INITIAL_SNAKE_LENGTH, MAX_STEPS_PER_GAME,
                    pyAI1Func, pyAI2Func,
                    activeP1.name, activeP2.name
                );
                
                const initialStateProxy = pyGameEnv.get_state();
                const initialState = initialStateProxy.toJs({ dict_converter: Object.fromEntries, create_proxies: false });
                initialStateProxy.destroy();
                renderGame(initialState); 

                statusDiv.textContent = "Battle starting..."; // This should be quickly overwritten by gameStep's status
                showLoadingStatus(""); 
                gameLoopInterval = setIntervale.g. fullscreen toggle)
            
            updateCanvasDimensionsAndClear(); // Clears and sets correct canvas size
            // drawGrid(); // Optional

            if (gameState.foods) drawFoods(gameState.foods);
            
            let p1SnakeData = gameState.snake1;
            let p2SnakeData = gameState.snake2;
            
            let p1DisplayName = activeP1 ? activeP1.name : (p1SnakeData ? p1SnakeData.name : "P1");
            let p2DisplayName = activeP2 ? activeP2.name : (p2SnakeData ? p2SnakeData.name : "P2");

            if (p1SnakeData) drawSnake(p1SnakeData, SNAKE_1_COLOR,(gameStep, GAME_SPEED_MS);
                isLoading = false; // Setup complete, game loop started

                // Buttons state after successful start:
                // startTournamentBtn remains disabled (battle running)
                // nextBattleBtn remains disabled (battle running)
                const canHaveMoreBattles = (currentKing && championsList.filter(c => c. SNAKE_1_HEAD_COLOR);
            if (p2SnakeData) drawSnake(p2SnakeData, SNAKE_2_COLOR, SNAKE_2_HEAD_COLOR);

            const s1Score = p1SnakeData ? p1SnakeData.score : 0;
            const s2Score = p2SnakeData ? p2SnakeData.score : 0;
            
            aiNamesDiv.innerHTML = `<span class="snake1-name-display">${p1DisplayName}</span> vs <span class="snake2-name-displayname !== currentKing.name).length > 0) || (!currentKing && championsList.length >=2);
                autoBattleCheckbox.disabled = !canHaveMoreBattles;


            } catch (error) {
                showError(`Failed to start battle: ${error.message}`);
                console.error("Detailed battle setup error:", error);
                statusDiv.textContent = "Error starting battle. See console.";
                isLoading = false; 
                startTournamentBtn.disabled = false;
                const canContinue = (currentKing && championsList.filter(c => c.name !== currentKing.name).length > 0) || (!currentKing && championsList.length >=2);
                nextBattleBtn.disabled = !canContinue;
                autoBattleCheckbox.disabled = !canContinue;
            }
        }
        
        function handleStartTournament() {
            ">${p2DisplayName}</span>`;
            scoresDiv.textContent = `Score: ${p1DisplayName} (${s1Score}) - ${p2DisplayName} (${s2Score})`;
            
            if (gameState.game_over) {
                // Status updated by gameStep after processing winner
            } else {
                statusDiv.textContent = `Step: ${gameState.steps_taken || 0} / ${MAX_STEPS_PER_GAME}`;
            }
        }

        // --- Game Loop ---
        function gameStep() { /* ... (same as V2, but ensure renderGame is called correctly) ... */
            if (!pyGameEnv || isLoading) return;

            try {
                const rawState = pyGameEnv.run_step();
                const gameState = rawStateclearMessages();
            showLoadingStatus("Starting new tournament with current config...");
            currentKing = null; 
            activeP1 = null; activeP2 = null;
            championsList.forEach(c => { 
                c.totalTournamentWins = 0; c.currentReignWins = 0; c.pyFunc = null; 
            });
            updateKingDisplay();
            updateLeaderboard(); 
            setupAndStartBattle(); // Uses current global config vars
        }

        function handleApplyConfigAndRestart() {
            applyCurrentConfig(); // Reads from UI, updates globals, resizes canvas
            handleStartTournament(); // Starts tournament with new config
.toJs({ dict_converter: Object.fromEntries, create_proxies: false }); 
                rawState.destroy(); 

                renderGame(gameState); // This will also update currentGameStateForRender

                if (gameState.game_over) {
                    clearInterval(gameLoopInterval);
                    gameLoopInterval = null;
                    isLoading = false; 
                    autoBattleStatusSpan.textContent = "";

                    let battleOutcomeMessage = "";
                    if (gameState.winner_name) {
                        const winnerObject = (gameState.winner_name === activeP1.name) ? activeP1 : activeP2;
                        if (winnerObject) { 
                            winnerObject        }

        // --- Event Listeners ---
        startTournamentBtn.addEventListener('click', handleStartTournament);
        nextBattleBtn.addEventListener('click', setupAndStartBattle);
        applyConfigBtn.addEventListener('click', handleApplyConfigAndRestart);
        fullscreenBtn.addEventListener('click', () => {
            const tournamentArea = document.getElementById('tournamentSection');
            if (!document.fullscreenElement) {
                tournamentArea.requestFullscreen().catch(err => {
                    showError(`Fullscreen error: ${err.message}`);
                });
            } else {
                if (.totalTournamentWins++;
                            if (!currentKing) { 
                                currentKing = winnerObject;
                                currentKing.currentReignWins = 1;
                                battleOutcomeMessage = ` ${currentKing.name} is the first King!`;
                            } else { 
                                if (winnerObject === currentKing) { 
                                    currentKing.currentReignWins++;
                                    battleOutcomeMessage = ` ${currentKing.name} remains King!`;
                                } else { 
                                    currentKing.currentReignWins = 0; 
                                    currentdocument.exitFullscreen) document.exitFullscreen();
            }
        });
        autoBattleCheckbox.addEventListener('change', () => { /* ... (unchanged) ... */ });

        // --- Initial Load ---
        async function main() {
            showLoadingStatus("Page loaded. Initializing...");
            applyCurrentConfig(); // Set initial JS vars from HTML defaults & resize canvas

            startTournamentBtn.disabled = true;
            nextBattleBtn.disabled = true;
            autoBattleCheckbox.disabled = true;
            updateLeaderboard(); 
            try {
                await initKing = winnerObject; 
                                    currentKing.currentReignWins = 1;
                                    battleOutcomeMessage = ` New King: ${currentKing.name}!`;
                                }
                            }
                        } else {
                             battleOutcomeMessage = ` Winner ${gameState.winner_name} not resolved.`;
                        }
                    } else { 
                        battleOutcomeMessage = " It's a draw!";
                        if (currentKing) battleOutcomeMessage += ` ${currentKing.name} remains King.`;
                        else battleOutcomeMessage += " No king decided yet.";
                    }
Pyodide();
                const manifestOK = await loadChampionsManifest(); 
                if (manifestOK && championsList.length >= 2) {
                    startTournamentBtn.disabled = false;
                    autoBattleCheckbox.disabled = false; 
                    showLoadingStatus("Ready to start a tournament!");
                } else {
                    startTournamentBtn.disabled = true;
                    autoBattleCheckbox.disabled = true;
                    if (!manifestOK) showError("Failed to load champion manifest.");
                }
            } catch (error) {
                startTournamentBtn.disabled = true;
                autoBattleCheckbox.disabled = true;
            }
            updateKingDisplay();
        }
        main();
    </script>
</body>
</html>
