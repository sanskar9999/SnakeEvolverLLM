<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake AI King of the Hill</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            background-color: #2c3e50; /* Darker background */
            color: #ecf0f1; /* Lighter text */
        }
        #mainLayout {
            display: flex;
            flex-direction: row;
            gap: 20px;
            width: 100%;
            max-width: 1200px; /* Max width for the whole layout */
            justify-content: center;
        }
        #tournamentSection {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
            border: 1px solid #34495e;
            padding: 20px;
            background-color: #34495e; /* Slightly lighter dark */
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 8px;
            /* width: auto; remove fixed width, let flex handle it */
            flex-grow: 1; /* Allow tournament section to take space */
            max-width: 700px; /* Max width for game area */
        }
        #leaderboardSection {
            display: flex;
            flex-direction: column;
            margin-top: 10px;
            border: 1px solid #34495e;
            padding: 20px;
            background-color: #34495e;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 8px;
            width: 300px; /* Fixed width for leaderboard */
            min-width: 250px;
        }
        #leaderboardSection h2 {
            margin-top: 0;
            text-align: center;
            color: #f1c40f;
        }
        #leaderboard {
            max-height: 450px; /* Max height before scroll */
            overflow-y: auto;
            padding-right: 10px; /* For scrollbar */
        }
        .leaderboard-item {
            padding: 8px 5px;
            border-bottom: 1px solid #2c3e50;
            display: flex;
            justify-content: space-between;
        }
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        .leaderboard-name { font-weight: bold; }
        .leaderboard-wins { color: #f1c40f; }

        canvas {
            border: 2px solid #ecf0f1;
            background-color: #1e272e; /* Dark canvas background */
            margin-bottom: 15px;
            border-radius: 4px;
        }
        #controls {
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }
         #tournamentInfo {
            margin-bottom: 10px; /* Reduced margin */
            display: flex;
            flex-direction: column; /* Stack king info and AI names */
            gap: 5px; /* Gap between king info and AI names */
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        button {
            padding: 10px 18px;
            font-size: 16px;
            background-color: #3498db; /* Blue */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #7f8c8d; /* Grayed out */
            cursor: not-allowed;
        }
        #status, #scores, #aiNames, #kingInfo {
            margin-top: 5px; /* Reduced margin */
            font-size: 1.1em;
            text-align: center;
        }
        #kingInfo { font-weight: bold; color: #f1c40f; /* Gold for king */}
        #aiNames span {
            padding: 4px 8px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
        }
        .snake1-name-display { background-color: #2ecc71; } /* Green */
        .snake2-name-display { background-color: #e74c3c; } /* Red */

        #loadingStatus, #autoBattleStatus {
            font-style: italic;
            color: #bdc3c7; /* Lighter gray */
            margin-top: 5px;
        }
        .error-message {
            color: #e74c3c; /* Red for errors */
            font-weight: bold;
            margin-top: 10px;
        }

        /* Responsive adjustments */
        @media (max-width: 900px) {
            #mainLayout {
                flex-direction: column;
                align-items: center;
            }
            #leaderboardSection {
                width: 90%;
                max-width: 700px; /* Match tournament section max-width */
                margin-top: 20px;
            }
            #tournamentSection {
                width: 90%;
            }
        }
         @media (max-width: 480px) {
            #controls {
                flex-direction: column;
            }
             button, #controls label {
                 width: 100%;
                 text-align: center;
             }
             #controls label input { margin-right: 5px;}
        }

    </style>
</head>
<body>
    <h1>Snake AI: King of the Hill</h1>

    <div id="mainLayout">
        <div id="tournamentSection">
            <div id="controls">
                <button id="startTournamentBtn">Start New Tournament</button>
                <button id="nextBattleBtn" disabled>Next Battle</button>
                <label for="autoBattleCheckbox" style="margin-left: 10px; display: inline-flex; align-items: center; cursor:pointer;">
                    <input type="checkbox" id="autoBattleCheckbox" style="margin-right: 5px;">Auto-Advance
                </label>
                <span id="autoBattleStatus" style="font-size: 0.9em;"></span>
            </div>
            <div id="tournamentInfo">
                <div id="kingInfo">Current King: --- (Reign Wins: 0)</div>
                <div id="aiNames">Player 1: --- vs Player 2: ---</div>
            </div>
            <div id="scores">Score: P1 (0) - P2 (0)</div>
            <canvas id="gameCanvas"></canvas>
            <div id="status">Welcome! Click "Start New Tournament".</div>
            <div id="loadingStatus"></div>
            <div id="errorMessage" class="error-message"></div>
        </div>

        <div id="leaderboardSection">
            <h2>Tournament Leaderboard</h2>
            <div id="leaderboard">
                <p>No tournament data yet.</p>
            </div>
        </div>
    </div>

    <script type="module">
        // --- Game Configuration ---
        const GRID_WIDTH = 20;
        const GRID_HEIGHT = 10;
        const INITIAL_SNAKE_LENGTH = 3;
        const CELL_SIZE = 28;
        const MAX_STEPS_PER_GAME = GRID_WIDTH * GRID_HEIGHT * 2;
        const GAME_SPEED_MS = 100;
        const AUTO_BATTLE_DELAY_MS = 3000; // 3 seconds

        const SNAKE_1_COLOR = "#2ecc71";
        const SNAKE_1_HEAD_COLOR = "#27ae60";
        const SNAKE_2_COLOR = "#e74c3c";
        const SNAKE_2_HEAD_COLOR = "#c0392b";
        const FOOD_COLOR = "#f1c40f";
        const GRID_LINE_COLOR = "#7f8c8d";

        // --- Python Game Engine Code (to be run in Pyodide) ---
        const PYTHON_ENGINE_CODE = `
import random
from collections import deque
from dataclasses import dataclass
from typing import List, Tuple, Optional, Callable # For type hints if AIs use them
import traceback # For better error reporting from AI

# --- Game Classes (adapted from your main_snake_game.py) ---
@dataclass
class Food:
    position: Tuple[int, int]

class Snake:
    DIRECTIONS_MAP = [(0, -1), (1, 0), (0, 1), (-1, 0)] # UP, RIGHT, DOWN, LEFT
    ACTIONS_LIST = [0, 1, 2, 3]
    OPPOSITE_ACTIONS_MAP = {0: 2, 1: 3, 2: 0, 3: 1}

    def __init__(self, x: int, y: int, grid_width: int, grid_height: int, initial_length: int, initial_direction_idx: Optional[int] = None):
        self.grid_width = grid_width
        self.grid_height = grid_height
        self.initial_length = initial_length 

        self.positions = deque()
        self.direction_idx = initial_direction_idx if initial_direction_idx is not None \
                             else random.choice(self.ACTIONS_LIST)
        self.length = initial_length
        self.score = 0
        self.is_alive = True
        self.name = "Snake" 

        head_pos = (x,y)
        self.positions.appendleft(head_pos)
        
        current_segment_x, current_segment_y = head_pos
        dx_segment_growth = -self.DIRECTIONS_MAP[self.direction_idx][0]
        dy_segment_growth = -self.DIRECTIONS_MAP[self.direction_idx][1]

        for _ in range(1, self.length):
            next_segment_x = (current_segment_x + dx_segment_growth + self.grid_width) % self.grid_width
            next_segment_y = (current_segment_y + dy_segment_growth + self.grid_height) % self.grid_height
            if (next_segment_x, next_segment_y) in self.positions: # Should be rare for short initial snakes
                # Fallback: try a different direction for segment growth if collision
                for alt_dir_idx in range(4):
                    if alt_dir_idx == self.direction_idx or alt_dir_idx == self.OPPOSITE_ACTIONS_MAP[self.direction_idx]:
                        continue
                    alt_dx_segment_growth = -self.DIRECTIONS_MAP[alt_dir_idx][0]
                    alt_dy_segment_growth = -self.DIRECTIONS_MAP[alt_dir_idx][1]
                    alt_next_segment_x = (current_segment_x + alt_dx_segment_growth + self.grid_width) % self.grid_width
                    alt_next_segment_y = (current_segment_y + alt_dy_segment_growth + self.grid_height) % self.grid_height
                    if (alt_next_segment_x, alt_next_segment_y) not in self.positions:
                        next_segment_x, next_segment_y = alt_next_segment_x, alt_next_segment_y
                        break
                if (next_segment_x, next_segment_y) in self.positions: # Still colliding
                    # This situation is tricky, may indicate very small grid or large initial length
                    # For simplicity, we'll allow it and it might resolve or lead to quick game over
                    print(f"Warning: Snake {self.name} initial body segment overlap during creation.")
                    break 
            self.positions.append((next_segment_x, next_segment_y))
            current_segment_x, current_segment_y = next_segment_x, next_segment_y
        
    def get_head_position(self) -> Tuple[int, int]:
        return self.positions[0]

    def get_current_direction_vector(self) -> Tuple[int, int]:
        return self.DIRECTIONS_MAP[self.direction_idx]

    def get_valid_actions(self) -> List[int]:
        if not self.is_alive: return []
        # For a 1-segment snake, any action is valid (no opposite if no body)
        if len(self.positions) <= 1:
            return list(self.ACTIONS_LIST)
        invalid_action = self.OPPOSITE_ACTIONS_MAP[self.direction_idx]
        return [a for a in self.ACTIONS_LIST if a != invalid_action]

    def move(self, action_idx: int) -> bool: 
        if not self.is_alive: return False

        valid_actions = self.get_valid_actions() # Get current valid actions
        if action_idx not in valid_actions:
             # This case should ideally be handled by the environment by giving AI valid actions
             # or AI choosing a valid one. If an invalid one (like reverse) gets here,
             # snake will try to move into its neck.
             # print(f"Snake {self.name} received an invalid action {action_idx}, current dir_idx {self.direction_idx}. This may lead to self-collision.")
             pass # Allow it, it will likely self-collide if it's a reverse.

        self.direction_idx = action_idx # Update direction regardless of immediate validity for game logic
        head_x, head_y = self.get_head_position()
        dx, dy = self.get_current_direction_vector()
        new_head = ((head_x + dx) % self.grid_width, (head_y + dy) % self.grid_height)

        # Check self-collision: new head collides with any part of the body *except* the current tail tip IF it's going to move
        body_to_check = list(self.positions)
        if len(self.positions) >= self.length: # Tail will move
             body_to_check = body_to_check[:-1]
        
        if new_head in body_to_check:
            self.is_alive = False
            return True # Died by self-collision

        self.positions.appendleft(new_head)
        if len(self.positions) > self.length:
            self.positions.pop()
        return False # Survived move

    def grow(self):
        if not self.is_alive: return
        self.length += 1
        self.score += 1

    def to_dict(self):
        return {
            "positions": list(self.positions),
            "direction_idx": self.direction_idx,
            "length": self.length,
            "score": self.score,
            "is_alive": self.is_alive,
            "name": self.name,
            "grid_width": self.grid_width,
            "grid_height": self.grid_height
        }

def load_ai_function_from_string(python_code_string: str, function_name: str = "get_challenger_action"):
    exec_globals = {
        "Snake": Snake, 
        "Food": Food,   
        "random": random,
        "deque": deque,
        "traceback": traceback # Allow AIs to use traceback for their own debugging if they want
    }
    try:
        exec(python_code_string, exec_globals)
        ai_function = exec_globals.get(function_name)
        if callable(ai_function):
            return ai_function
        else:
            print(f"Error: AI Function '{function_name}' not found or not callable after exec.")
            return None
    except Exception as e:
        print(f"Error executing AI code string: {e}")
        traceback.print_exc()
        return None

class SnakeEnvironment:
    def __init__(self, grid_width: int, grid_height: int, initial_snake_length: int, max_steps: int,
                 ai1_logic: Callable, ai2_logic: Callable, 
                 snake1_name: str = "P1", snake2_name: str = "P2"):
        self.grid_width = grid_width
        self.grid_height = grid_height
        self.initial_snake_length = initial_snake_length
        self.max_steps = max_steps
        self.ai1_logic = ai1_logic
        self.ai2_logic = ai2_logic
        self.snake1_name_init = snake1_name
        self.snake2_name_init = snake2_name
        self.reset()

    def reset(self):
        self.steps_taken = 0
        self.game_over = False
        self.winner_snake_obj_ref = None
        self.winner_message = ""
        
        s1_x, s1_y = self.grid_width // 4, self.grid_height // 2
        s1_dir = 1 # Right
        self.snake1 = Snake(s1_x, s1_y, self.grid_width, self.grid_height, self.initial_snake_length, initial_direction_idx=s1_dir)
        self.snake1.name = self.snake1_name_init

        s2_x, s2_y = self.grid_width * 3 // 4, self.grid_height // 2
        s2_dir = 3 # Left
        self.snake2 = Snake(s2_x, s2_y, self.grid_width, self.grid_height, self.initial_snake_length, initial_direction_idx=s2_dir)
        self.snake2.name = self.snake2_name_init

        if any(p in self.snake1.positions for p in self.snake2.positions) or \
           any(p in self.snake2.positions for p in self.snake1.positions):
            print("Initial snake overlap detected, attempting to adjust s2.")
            self.snake2 = Snake(s2_x, s2_y + 1 if s2_y + 1 < self.grid_height else s2_y -1 , self.grid_width, self.grid_height, self.initial_snake_length, initial_direction_idx=s2_dir)
            self.snake2.name = self.snake2_name_init
            if any(p in self.snake1.positions for p in self.snake2.positions):
                 print("Overlap still present after adjustment. This might lead to issues.")

        self.foods = []
        self._spawn_food() # Spawn one food
        self._spawn_food() # Spawn a second food if possible

    def _spawn_food(self):
        # Try to maintain 2 food items if space allows
        if len(self.foods) >= 2: return 

        occupied_cells = set()
        if self.snake1 and self.snake1.is_alive: occupied_cells.update(self.snake1.positions)
        if self.snake2 and self.snake2.is_alive: occupied_cells.update(self.snake2.positions)
        for food_item in self.foods: occupied_cells.add(food_item.position) # Don't spawn on existing food
        
        empty_cells = [(x, y) for x in range(self.grid_width) for y in range(self.grid_height) if (x,y) not in occupied_cells]
        if empty_cells:
            self.foods.append(Food(random.choice(empty_cells)))

    def _get_actions_from_ais(self):
        # Default to current direction if AI fails or snake dead
        action1 = self.snake1.direction_idx if self.snake1 else 0
        action2 = self.snake2.direction_idx if self.snake2 else 0
        
        # Prepare AI observation
        # For simplicity, AI receives its own snake, opponent (if alive), list of food objects, grid dimensions
        # Convert food objects to simple list of tuples for AIs if they prefer
        # foods_for_ai = [f.position for f in self.foods] # Option 1: simple positions
        foods_for_ai = list(self.foods) # Option 2: list of Food objects

        if self.snake1 and self.snake1.is_alive:
            valid_actions1 = self.snake1.get_valid_actions()
            if valid_actions1:
                try:
                    opponent_s1 = self.snake2 if self.snake2 and self.snake2.is_alive else None
                    act1_candidate = self.ai1_logic(self.snake1, opponent_s1, foods_for_ai, self.grid_width, self.grid_height)
                    action1 = act1_candidate if act1_candidate in valid_actions1 else random.choice(valid_actions1)
                except Exception as e:
                    print(f"Error in AI1 ({self.snake1.name}) logic: {e}. Choosing random valid action.")
                    traceback.print_exc()
                    action1 = random.choice(valid_actions1)
        
        if self.snake2 and self.snake2.is_alive:
            valid_actions2 = self.snake2.get_valid_actions()
            if valid_actions2:
                try:
                    opponent_s2 = self.snake1 if self.snake1 and self.snake1.is_alive else None
                    act2_candidate = self.ai2_logic(self.snake2, opponent_s2, foods_for_ai, self.grid_width, self.grid_height)
                    action2 = act2_candidate if act2_candidate in valid_actions2 else random.choice(valid_actions2)
                except Exception as e:
                    print(f"Error in AI2 ({self.snake2.name}) logic: {e}. Choosing random valid action.")
                    traceback.print_exc()
                    action2 = random.choice(valid_actions2)
        return action1, action2

    def run_step(self):
        if self.game_over:
            return self.get_state()

        action1, action2 = self._get_actions_from_ais()
        self.steps_taken += 1

        # Move snakes
        s1_died_self = self.snake1.move(action1) if self.snake1 and self.snake1.is_alive else False
        s2_died_self = self.snake2.move(action2) if self.snake2 and self.snake2.is_alive else False
        
        # Check collisions between snakes
        s1_hit_s2_body, s2_hit_s1_body = False, False
        head_on_collision_s1_dies, head_on_collision_s2_dies = False, False

        if self.snake1.is_alive and self.snake2.is_alive:
            h1_pos, h2_pos = self.snake1.get_head_position(), self.snake2.get_head_position()
            
            if h1_pos == h2_pos: # Head-on collision
                if self.snake1.length > self.snake2.length: head_on_collision_s2_dies = True
                elif self.snake2.length > self.snake1.length: head_on_collision_s1_dies = True
                else: head_on_collision_s1_dies, head_on_collision_s2_dies = True, True # Both die
            else:
                # Check if s1 head ran into s2 body (excluding s2's new head)
                if h1_pos in list(self.snake2.positions)[1:]: s1_hit_s2_body = True
                # Check if s2 head ran into s1 body (excluding s1's new head)
                if h2_pos in list(self.snake1.positions)[1:]: s2_hit_s1_body = True
        
        # Update snake aliveness based on collisions
        if s1_died_self or head_on_collision_s1_dies or s1_hit_s2_body: self.snake1.is_alive = False
        if s2_died_self or head_on_collision_s2_dies or s2_hit_s1_body: self.snake2.is_alive = False
        
        # Food eating (multiple foods)
        food_eaten_indices = []
        if self.snake1.is_alive:
            s1_head = self.snake1.get_head_position()
            for i, food in enumerate(self.foods):
                if s1_head == food.position:
                    self.snake1.grow()
                    food_eaten_indices.append(i)
                    break # Snake can only eat one food per step
        
        if self.snake2.is_alive:
            s2_head = self.snake2.get_head_position()
            for i, food in enumerate(self.foods):
                if i in food_eaten_indices: continue # Already eaten by s1
                if s2_head == food.position:
                    self.snake2.grow()
                    food_eaten_indices.append(i)
                    break 
        
        # Remove eaten food and spawn new ones
        if food_eaten_indices:
            # Remove from highest index to lowest to maintain list integrity
            for i in sorted(food_eaten_indices, reverse=True):
                del self.foods[i]
            for _ in range(len(food_eaten_indices)): # Try to replace eaten food
                 self._spawn_food()


        # Determine game over and winner
        s1_alive = self.snake1 and self.snake1.is_alive
        s2_alive = self.snake2 and self.snake2.is_alive

        if not s1_alive and not s2_alive:
            self.game_over = True
            if self.snake1.score > self.snake2.score: 
                self.winner_message = f"{self.snake1.name} wins by score! (Both eliminated)"
                self.winner_snake_obj_ref = self.snake1
            elif self.snake2.score > self.snake1.score: 
                self.winner_message = f"{self.snake2.name} wins by score! (Both eliminated)"
                self.winner_snake_obj_ref = self.snake2
            else: self.winner_message = "Draw! (Both eliminated, same score)"
        elif not s1_alive:
            self.game_over = True; self.winner_message = f"{self.snake2.name} wins! ({self.snake1.name} eliminated)"
            self.winner_snake_obj_ref = self.snake2
        elif not s2_alive:
            self.game_over = True; self.winner_message = f"{self.snake1.name} wins! ({self.snake2.name} eliminated)"
            self.winner_snake_obj_ref = self.snake1
        elif self.steps_taken >= self.max_steps:
            self.game_over = True
            if self.snake1.score > self.snake2.score: 
                self.winner_message = f"{self.snake1.name} wins by score! (Max steps)"
                self.winner_snake_obj_ref = self.snake1
            elif self.snake2.score > self.snake1.score: 
                self.winner_message = f"{self.snake2.name} wins by score! (Max steps)"
                self.winner_snake_obj_ref = self.snake2
            elif self.snake1.length > self.snake2.length: 
                self.winner_message = f"{self.snake1.name} wins by length! (Max steps, same score)"
                self.winner_snake_obj_ref = self.snake1
            elif self.snake2.length > self.snake1.length: 
                self.winner_message = f"{self.snake2.name} wins by length! (Max steps, same score)"
                self.winner_snake_obj_ref = self.snake2
            else: self.winner_message = "Draw! (Max steps, same score & length)"
        
        # Ensure at least one food item if possible
        if not self.foods and (s1_alive or s2_alive):
            self._spawn_food()

        return self.get_state()

    def get_state(self):
        winner_name = None
        if self.winner_snake_obj_ref:
            winner_name = self.winner_snake_obj_ref.name

        return {
            "snake1": self.snake1.to_dict() if self.snake1 else None,
            "snake2": self.snake2.to_dict() if self.snake2 else None,
            "foods": [food.position for food in self.foods],
            "game_over": self.game_over,
            "steps_taken": self.steps_taken,
            "grid_width": self.grid_width,
            "grid_height": self.grid_height,
            "winner_message": self.winner_message,
            "winner_name": winner_name
        }

print("Python Snake Game Engine (for Web/Pyodide) Loaded. V2")
`;

        // --- UI Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startTournamentBtn = document.getElementById('startTournamentBtn');
        const nextBattleBtn = document.getElementById('nextBattleBtn');
        const autoBattleCheckbox = document.getElementById('autoBattleCheckbox');
        const autoBattleStatusSpan = document.getElementById('autoBattleStatus');
        const statusDiv = document.getElementById('status');
        const scoresDiv = document.getElementById('scores');
        const aiNamesDiv = document.getElementById('aiNames');
        const kingInfoDiv = document.getElementById('kingInfo');
        const loadingStatusDiv = document.getElementById('loadingStatus');
        const errorMessageDiv = document.getElementById('errorMessage');
        const leaderboardDiv = document.getElementById('leaderboard');


        // --- Pyodide and Game State ---
        let pyodide = null;
        let pyGameEnv = null;
        let championsList = []; // Array of {name: string, file: string, pyFunc: PyProxy, totalTournamentWins: 0, currentReignWins: 0}
        let gameLoopInterval = null;
        let isLoading = false;
        let autoBattleTimeoutId = null;


        // --- Tournament State ---
        let currentKing = null; // Reference to a champion object from championsList
        let activeP1 = null; // Reference to champion object for player 1 in current battle
        let activeP2 = null; // Reference to champion object for player 2 in current battle

        // --- Canvas Setup ---
        canvas.width = GRID_WIDTH * CELL_SIZE;
        canvas.height = GRID_HEIGHT * CELL_SIZE;

        // --- Helper Functions ---
        function showError(message) {
            errorMessageDiv.textContent = message;
            console.error(message);
        }
        function showLoadingStatus(message) {
            loadingStatusDiv.textContent = message;
        }
        function clearMessages() {
            errorMessageDiv.textContent = '';
            // loadingStatusDiv.textContent = ''; // Keep loading status sometimes
        }
        function updateKingDisplay() {
            if (currentKing) {
                kingInfoDiv.textContent = `Current King: ${currentKing.name} (Reign Wins: ${currentKing.currentReignWins})`;
            } else {
                kingInfoDiv.textContent = "Current King: --- (Reign Wins: 0)";
            }
        }
        function updateLeaderboard() {
            if (championsList.length === 0) {
                leaderboardDiv.innerHTML = "<p>No champions loaded.</p>";
                return;
            }
            // Sort by totalTournamentWins descending, then by name ascending for ties
            const sortedChampions = [...championsList].sort((a, b) => {
                if (b.totalTournamentWins !== a.totalTournamentWins) {
                    return b.totalTournamentWins - a.totalTournamentWins;
                }
                return a.name.localeCompare(b.name);
            });

            leaderboardDiv.innerHTML = sortedChampions.map(champ => `
                <div class="leaderboard-item">
                    <span class="leaderboard-name">${champ.name}</span>
                    <span class="leaderboard-wins">${champ.totalTournamentWins} wins</span>
                </div>
            `).join('');
            if (sortedChampions.length === 0) {
                 leaderboardDiv.innerHTML = "<p>No tournament data yet.</p>";
            }
        }


        // --- Pyodide Initialization ---
        async function initPyodide() {
            if (pyodide) return pyodide;
            isLoading = true;
            startTournamentBtn.disabled = true;
            nextBattleBtn.disabled = true;
            autoBattleCheckbox.disabled = true;
            showLoadingStatus("Loading Pyodide runtime...");
            try {
                pyodide = await loadPyodide();
                showLoadingStatus("Pyodide loaded. Loading Python game engine...");
                await pyodide.runPythonAsync(PYTHON_ENGINE_CODE);
                showLoadingStatus("Python game engine ready.");
                return pyodide;
            } catch (error) {
                showError(`Pyodide initialization failed: ${error}`);
                throw error;
            } finally {
                isLoading = false;
                // Button enabling handled after champion list load
            }
        }

        // --- Champion Loading ---
        async function loadChampionsManifest() {
            showLoadingStatus("Fetching champion list...");
            try {
                const response = await fetch('./past_champions/champions_manifest.json');
                if (!response.ok) {
                    throw new Error(`Failed to fetch champions_manifest.json: ${response.statusText}`);
                }
                const rawList = await response.json();
                if (!Array.isArray(rawList)) {
                     throw new Error("Champions manifest is not a valid JSON array.");
                }
                championsList = rawList.map(champ => ({ 
                    name: champ.name, 
                    file: champ.file, 
                    pyFunc: null, 
                    totalTournamentWins: 0,
                    currentReignWins: 0 
                }));
                
                if (championsList.length < 2) {
                    showError(`Not enough champions (found ${championsList.length}, need at least 2). Tournament cannot start.`);
                    updateLeaderboard(); // Show empty or few champs
                    return false;
                }
                showLoadingStatus(`Found ${championsList.length} champions. Ready for tournament!`);
                updateLeaderboard();
                return true;
            } catch (error) {
                showError(`Error loading champions: ${error}`);
                championsList = [];
                updateLeaderboard();
                return false;
            }
        }
        
        async function loadAIFunctionIfNeeded(aiInfo) {
            if (aiInfo.pyFunc) return aiInfo.pyFunc;

            showLoadingStatus(`Loading AI: ${aiInfo.name}...`);
            try {
                const response = await fetch(`./past_champions/${aiInfo.file}`);
                if (!response.ok) throw new Error(`Failed to fetch AI file ${aiInfo.file}: ${response.statusText}`);
                const aiCode = await response.text();
                
                if (!pyodide || !pyodide.globals.get('load_ai_function_from_string')) {
                     await initPyodide(); 
                }
                const pyLoaderFunc = pyodide.globals.get('load_ai_function_from_string');
                if (!pyLoaderFunc){
                    throw new Error("Python function 'load_ai_function_from_string' not available.");
                }

                const pyAIFunction = pyLoaderFunc(aiCode);
                if (!pyAIFunction) {
                    throw new Error(`Could not load AI function from ${aiInfo.file}. Check Python console output for details from 'load_ai_function_from_string'.`);
                }
                aiInfo.pyFunc = pyAIFunction;
                showLoadingStatus(`AI ${aiInfo.name} loaded.`);
                return pyAIFunction;
            } catch (error) {
                showError(`Error loading AI ${aiInfo.name} (${aiInfo.file}): ${error}`);
                console.error("Detailed AI loading error:", error, "AI Info:", aiInfo);
                throw error;
            }
        }

        // --- Drawing Functions ---
        function drawGrid() { /* ... unchanged ... */ }
        function drawSnake(snakeData, color, headColor) { /* ... unchanged ... */ }
        function drawFoods(foodsList) { /* ... unchanged ... */ }

        function renderGame(gameState) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // drawGrid(); // Optional

            if (gameState.foods) {
                drawFoods(gameState.foods);
            }
            
            let p1SnakeData = gameState.snake1;
            let p2SnakeData = gameState.snake2;
            
            let p1DisplayName = activeP1 ? activeP1.name : (p1SnakeData ? p1SnakeData.name : "P1");
            let p2DisplayName = activeP2 ? activeP2.name : (p2SnakeData ? p2SnakeData.name : "P2");

            if (p1SnakeData) drawSnake(p1SnakeData, SNAKE_1_COLOR, SNAKE_1_HEAD_COLOR);
            if (p2SnakeData) drawSnake(p2SnakeData, SNAKE_2_COLOR, SNAKE_2_HEAD_COLOR);

            const s1Score = p1SnakeData ? p1SnakeData.score : 0;
            const s2Score = p2SnakeData ? p2SnakeData.score : 0;
            
            aiNamesDiv.innerHTML = `<span class="snake1-name-display">${p1DisplayName}</span> vs <span class="snake2-name-display">${p2DisplayName}</span>`;
            scoresDiv.textContent = `Score: ${p1DisplayName} (${s1Score}) - ${p2DisplayName} (${s2Score})`;
            
            if (gameState.game_over) {
                // Status updated by gameStep after processing winner
            } else {
                statusDiv.textContent = `Step: ${gameState.steps_taken || 0} / ${MAX_STEPS_PER_GAME}`;
            }
        }

        // --- Game Loop ---
        function gameStep() {
            if (!pyGameEnv || isLoading) return;

            try {
                const rawState = pyGameEnv.run_step();
                const gameState = rawState.toJs({ dict_converter: Object.fromEntries, create_proxies: false }); 
                rawState.destroy(); 

                renderGame(gameState);

                if (gameState.game_over) {
                    clearInterval(gameLoopInterval);
                    gameLoopInterval = null;
                    isLoading = false; // Battle finished loading/processing
                    autoBattleStatusSpan.textContent = "";


                    let battleOutcomeMessage = "";
                    if (gameState.winner_name) {
                        const winnerObject = (gameState.winner_name === activeP1.name) ? activeP1 : activeP2;
                        if (winnerObject) { // Ensure winnerObject is found
                            winnerObject.totalTournamentWins++;

                            if (!currentKing) { // First battle of tournament
                                currentKing = winnerObject;
                                currentKing.currentReignWins = 1;
                                battleOutcomeMessage = ` ${currentKing.name} is the first King!`;
                            } else { // Subsequent battles
                                if (winnerObject === currentKing) { // Current King (activeP1) won
                                    currentKing.currentReignWins++;
                                    battleOutcomeMessage = ` ${currentKing.name} remains King!`;
                                } else { // Challenger (activeP2) won
                                    currentKing.currentReignWins = 0; // End old king's reign
                                    currentKing = winnerObject; // Challenger becomes new king
                                    currentKing.currentReignWins = 1;
                                    battleOutcomeMessage = ` New King: ${currentKing.name}!`;
                                }
                            }
                        } else {
                             battleOutcomeMessage = ` Winner ${gameState.winner_name} not resolved to player object.`;
                        }
                    } else { // Draw
                        battleOutcomeMessage = " It's a draw!";
                        if (currentKing) {
                            battleOutcomeMessage += ` ${currentKing.name} remains King.`;
                        } else {
                            battleOutcomeMessage += " No king decided yet.";
                        }
                    }
                    statusDiv.textContent = `Game Over! ${gameState.winner_message || "No winner determined."}${battleOutcomeMessage}`;
                    updateKingDisplay();
                    updateLeaderboard();
                    
                    // Auto-battle logic
                    const canContinue = currentKing && championsList.filter(c => c.name !== currentKing.name).length > 0 || !currentKing && championsList.length >=2;

                    if (autoBattleCheckbox.checked && canContinue) {
                        autoBattleStatusSpan.textContent = `Next battle in ${AUTO_BATTLE_DELAY_MS/1000}s...`;
                        nextBattleBtn.disabled = true;
                        autoBattleTimeoutId = setTimeout(() => {
                             if (autoBattleCheckbox.checked) { // check again in case it was unchecked during timeout
                                setupAndStartBattle();
                             } else {
                                nextBattleBtn.disabled = !canContinue; // re-enable if unchecked and can continue
                                autoBattleStatusSpan.textContent = "";
                             }
                        }, AUTO_BATTLE_DELAY_MS);
                    } else {
                        nextBattleBtn.disabled = !canContinue;
                        startTournamentBtn.disabled = false;
                        autoBattleCheckbox.disabled = !canContinue;
                        if (!canContinue && currentKing) {
                            statusDiv.textContent += ` King ${currentKing.name} has defeated all challengers! Tournament Over.`;
                            showLoadingStatus("Ultimate Champion crowned!");
                        }
                    }
                }
            } catch (error) {
                showError(`Error during game step: ${error}`);
                console.error("Detailed game step error:", error);
                clearInterval(gameLoopInterval);
                gameLoopInterval = null;
                isLoading = false;
                startTournamentBtn.disabled = false;
                nextBattleBtn.disabled = true; // Safer to disable
                autoBattleCheckbox.disabled = false;
                autoBattleStatusSpan.textContent = "";

            }
        }

        async function setupAndStartBattle() {
            clearMessages();
            if (isLoading) {
                showError("Previous operation still in progress, please wait.");
                return;
            }
            if (gameLoopInterval) { 
                clearInterval(gameLoopInterval);
                gameLoopInterval = null;
            }
            if (autoBattleTimeoutId) {
                clearTimeout(autoBattleTimeoutId);
                autoBattleTimeoutId = null;
                autoBattleStatusSpan.textContent = "";
            }

            isLoading = true;
            startTournamentBtn.disabled = true;
            nextBattleBtn.disabled = true;
            autoBattleCheckbox.disabled = true; // Disable during setup
            statusDiv.textContent = "Setting up new battle...";

            try {
                if (!pyodide) await initPyodide();
                if (championsList.length === 0) { // Should have been caught by manifest load
                    const manifestLoaded = await loadChampionsManifest();
                    if (!manifestLoaded || championsList.length < 2) {
                         showError("Cannot start: Not enough champions (need at least 2). Check manifest.");
                         isLoading = false; startTournamentBtn.disabled = false; autoBattleCheckbox.disabled = false; return;
                    }
                }

                let player1AI, player2AI;
                if (!currentKing) { // First battle of a tournament
                    if (championsList.length < 2) {
                        showError("Need at least 2 champions for the first battle.");
                        isLoading = false; startTournamentBtn.disabled = false; autoBattleCheckbox.disabled = false; return;
                    }
                    // Shuffle champions list to pick first two randomly for better variety
                    let shuffledChamps = [...championsList].sort(() => 0.5 - Math.random());
                    player1AI = shuffledChamps[0];
                    player2AI = shuffledChamps[1];
                } else { // King vs. Challenger
                    player1AI = currentKing;
                    let availableChallengers = championsList.filter(c => c.name !== currentKing.name);
                    if (availableChallengers.length === 0) {
                        showError(`King ${currentKing.name} has defeated all challengers! Tournament ends.`);
                        statusDiv.textContent = `King ${currentKing.name} is the Ultimate Champion!`;
                        isLoading = false; startTournamentBtn.disabled = false; autoBattleCheckbox.disabled = true; return;
                    }
                    player2AI = availableChallengers[Math.floor(Math.random() * availableChallengers.length)];
                }
                
                activeP1 = player1AI;
                activeP2 = player2AI;

                statusDiv.textContent = `Loading AIs: ${activeP1.name} vs ${activeP2.name}`;
                const pyAI1Func = await loadAIFunctionIfNeeded(activeP1);
                const pyAI2Func = await loadAIFunctionIfNeeded(activeP2);

                if (!pyAI1Func || !pyAI2Func) {
                    throw new Error("One or both AI functions failed to load. Check console for Python errors.");
                }
                
                const PySnakeEnvironment = pyodide.globals.get('SnakeEnvironment');
                if (!PySnakeEnvironment) throw new Error("Python class 'SnakeEnvironment' not found.");

                pyGameEnv = PySnakeEnvironment(
                    GRID_WIDTH, GRID_HEIGHT, INITIAL_SNAKE_LENGTH, MAX_STEPS_PER_GAME,
                    pyAI1Func, pyAI2Func,
                    activeP1.name, activeP2.name
                );
                
                const initialStateProxy = pyGameEnv.get_state();
                const initialState = initialStateProxy.toJs({ dict_converter: Object.fromEntries, create_proxies: false });
                initialStateProxy.destroy();
                renderGame(initialState); 

                statusDiv.textContent = "Battle starting...";
                showLoadingStatus(""); // Clear loading messages once battle starts
                gameLoopInterval = setInterval(gameStep, GAME_SPEED_MS);
                // isLoading will be set to false when battle ends or if an error occurs during the loop.

            } catch (error) {
                showError(`Failed to start battle: ${error.message}`);
                console.error("Detailed battle setup error:", error);
                statusDiv.textContent = "Error starting battle. See console.";
                isLoading = false; // Critical to reset loading state on error
                startTournamentBtn.disabled = false;
                // Enable next battle if a king exists and there are challengers
                const canContinue = currentKing && championsList.filter(c => c.name !== currentKing.name).length > 0 || !currentKing && championsList.length >=2;
                nextBattleBtn.disabled = !canContinue;
                autoBattleCheckbox.disabled = !canContinue;
            } finally {
                // If gameLoopInterval is not set (error before loop start), ensure isLoading is false
                if (!gameLoopInterval) {
                    isLoading = false;
                }
            }
        }
        
        function handleStartTournament() {
            clearMessages();
            showLoadingStatus("Starting new tournament...");
            currentKing = null; 
            activeP1 = null;
            activeP2 = null;
            championsList.forEach(c => { 
                c.totalTournamentWins = 0; 
                c.currentReignWins = 0;
                c.pyFunc = null; // Force reload of AI functions
            });
            updateKingDisplay();
            updateLeaderboard(); // Reset leaderboard display
            setupAndStartBattle();
        }

        // --- Event Listeners ---
        startTournamentBtn.addEventListener('click', handleStartTournament);
        nextBattleBtn.addEventListener('click', setupAndStartBattle);
        autoBattleCheckbox.addEventListener('change', () => {
            if (!autoBattleCheckbox.checked && autoBattleTimeoutId) { // If unchecked during countdown
                clearTimeout(autoBattleTimeoutId);
                autoBattleTimeoutId = null;
                autoBattleStatusSpan.textContent = "";
                const canContinue = currentKing && championsList.filter(c => c.name !== currentKing.name).length > 0 || !currentKing && championsList.length >=2;
                if (!gameLoopInterval && !isLoading) { // If game is not running and not loading
                     nextBattleBtn.disabled = !canContinue;
                }
            }
        });


        // --- Initial Load ---
        async function main() {
            showLoadingStatus("Page loaded. Initializing...");
            startTournamentBtn.disabled = true;
            nextBattleBtn.disabled = true;
            autoBattleCheckbox.disabled = true;
            updateLeaderboard(); // Show initial empty state
            try {
                await initPyodide();
                const manifestOK = await loadChampionsManifest(); // This now also updates leaderboard
                if (manifestOK && championsList.length >= 2) {
                    startTournamentBtn.disabled = false;
                    autoBattleCheckbox.disabled = false; // Can enable if tournament can start
                    showLoadingStatus("Ready to start a tournament!");
                } else {
                    startTournamentBtn.disabled = true;
                    autoBattleCheckbox.disabled = true;
                    if (!manifestOK) showError("Failed to load champion manifest. Cannot start.");
                    // Error for insufficient champions is now handled in loadChampionsManifest
                }
            } catch (error) {
                // Error already shown by initPyodide or loadChampionsManifest
                startTournamentBtn.disabled = true;
                autoBattleCheckbox.disabled = true;
            }
            updateKingDisplay();
        }

        main();

    </script>
</body>
</html>